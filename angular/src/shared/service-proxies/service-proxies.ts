/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.13.2.0 (NJsonSchema v10.5.2.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

import * as moment from 'moment';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class AccountServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    isTenantAvailable(body: IsTenantAvailableInput | undefined): Observable<IsTenantAvailableOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/IsTenantAvailable";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsTenantAvailable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsTenantAvailable(<any>response_);
                } catch (e) {
                    return <Observable<IsTenantAvailableOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<IsTenantAvailableOutput>><any>_observableThrow(response_);
        }));
    }

    protected processIsTenantAvailable(response: HttpResponseBase): Observable<IsTenantAvailableOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IsTenantAvailableOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IsTenantAvailableOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    register(body: RegisterInput | undefined): Observable<RegisterOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/Register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegister(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegister(<any>response_);
                } catch (e) {
                    return <Observable<RegisterOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<RegisterOutput>><any>_observableThrow(response_);
        }));
    }

    protected processRegister(response: HttpResponseBase): Observable<RegisterOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RegisterOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RegisterOutput>(<any>null);
    }
}

@Injectable()
export class CommonServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllBanks(): Observable<CommonKeyValuePairDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Common/GetAllBanks";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllBanks(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllBanks(<any>response_);
                } catch (e) {
                    return <Observable<CommonKeyValuePairDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonKeyValuePairDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllBanks(response: HttpResponseBase): Observable<CommonKeyValuePairDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(CommonKeyValuePairDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonKeyValuePairDto[]>(<any>null);
    }
}

@Injectable()
export class ConfigurationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changeUiTheme(body: ChangeUiThemeInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Configuration/ChangeUiTheme";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeUiTheme(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeUiTheme(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processChangeUiTheme(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class DocumentSequenceNumberManagerImplementationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    syncDocumentSequenceNumber(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DocumentSequenceNumberManagerImplementation/SyncDocumentSequenceNumber";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSyncDocumentSequenceNumber(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSyncDocumentSequenceNumber(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSyncDocumentSequenceNumber(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param documentType (optional) 
     * @return Success
     */
    getNextDocumentNumber(documentType: number | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/DocumentSequenceNumberManagerImplementation/GetNextDocumentNumber?";
        if (documentType === null)
            throw new Error("The parameter 'documentType' cannot be null.");
        else if (documentType !== undefined)
            url_ += "documentType=" + encodeURIComponent("" + documentType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNextDocumentNumber(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNextDocumentNumber(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetNextDocumentNumber(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param documentType (optional) 
     * @return Success
     */
    getAndUpdateNextDocumentNumber(documentType: DocumentType | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/DocumentSequenceNumberManagerImplementation/GetAndUpdateNextDocumentNumber?";
        if (documentType === null)
            throw new Error("The parameter 'documentType' cannot be null.");
        else if (documentType !== undefined)
            url_ += "documentType=" + encodeURIComponent("" + documentType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAndUpdateNextDocumentNumber(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAndUpdateNextDocumentNumber(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetAndUpdateNextDocumentNumber(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }
}

@Injectable()
export class FinanceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createInvoice(body: CreateInvoiceDto | undefined): Observable<InvoiceDto> {
        let url_ = this.baseUrl + "/api/services/app/Finance/CreateInvoice";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateInvoice(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateInvoice(<any>response_);
                } catch (e) {
                    return <Observable<InvoiceDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<InvoiceDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateInvoice(response: HttpResponseBase): Observable<InvoiceDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InvoiceDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InvoiceDto>(<any>null);
    }
}

@Injectable()
export class InventoryServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createGoodsReceivedNote(body: CreateGoodsReceivedDto | undefined): Observable<GoodsReceivedDto> {
        let url_ = this.baseUrl + "/api/services/app/Inventory/CreateGoodsReceivedNote";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateGoodsReceivedNote(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateGoodsReceivedNote(<any>response_);
                } catch (e) {
                    return <Observable<GoodsReceivedDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GoodsReceivedDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateGoodsReceivedNote(response: HttpResponseBase): Observable<GoodsReceivedDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GoodsReceivedDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GoodsReceivedDto>(<any>null);
    }

    /**
     * @param keyword (optional) 
     * @param isActive (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllGoodsReceivedProducts(keyword: string | null | undefined, isActive: boolean | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<GoodsReceivedDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Inventory/GetAllGoodsReceivedProducts?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (isActive !== undefined && isActive !== null)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllGoodsReceivedProducts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllGoodsReceivedProducts(<any>response_);
                } catch (e) {
                    return <Observable<GoodsReceivedDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GoodsReceivedDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllGoodsReceivedProducts(response: HttpResponseBase): Observable<GoodsReceivedDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GoodsReceivedDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GoodsReceivedDtoPagedResultDto>(<any>null);
    }

    /**
     * @return Success
     */
    syncStockBalances(): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/Inventory/SyncStockBalances";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSyncStockBalances(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSyncStockBalances(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processSyncStockBalances(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }
}

@Injectable()
export class ProductionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createProduct(body: CreateProductDto | undefined): Observable<ProductDto> {
        let url_ = this.baseUrl + "/api/services/app/Production/CreateProduct";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateProduct(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateProduct(<any>response_);
                } catch (e) {
                    return <Observable<ProductDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProductDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateProduct(response: HttpResponseBase): Observable<ProductDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteProduct(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Production/DeleteProduct?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteProduct(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteProduct(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteProduct(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getProduct(id: string | undefined): Observable<ProductDto> {
        let url_ = this.baseUrl + "/api/services/app/Production/GetProduct?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProduct(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProduct(<any>response_);
                } catch (e) {
                    return <Observable<ProductDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProductDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetProduct(response: HttpResponseBase): Observable<ProductDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductDto>(<any>null);
    }

    /**
     * @param keyword (optional) 
     * @param isActive (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllProducts(keyword: string | null | undefined, isActive: boolean | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<ProductDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Production/GetAllProducts?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (isActive !== undefined && isActive !== null)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllProducts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllProducts(<any>response_);
                } catch (e) {
                    return <Observable<ProductDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProductDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllProducts(response: HttpResponseBase): Observable<ProductDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductDtoPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateProduct(body: UpdateProductDto | undefined): Observable<ProductDto> {
        let url_ = this.baseUrl + "/api/services/app/Production/UpdateProduct";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateProduct(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateProduct(<any>response_);
                } catch (e) {
                    return <Observable<ProductDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProductDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateProduct(response: HttpResponseBase): Observable<ProductDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductDto>(<any>null);
    }

    /**
     * @param keyword (optional) 
     * @return Success
     */
    getPartialProducts(keyword: string | null | undefined): Observable<CommonKeyValuePairDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Production/GetPartialProducts?";
        if (keyword !== undefined && keyword !== null)
            url_ += "keyword=" + encodeURIComponent("" + keyword) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPartialProducts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPartialProducts(<any>response_);
                } catch (e) {
                    return <Observable<CommonKeyValuePairDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonKeyValuePairDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetPartialProducts(response: HttpResponseBase): Observable<CommonKeyValuePairDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(CommonKeyValuePairDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonKeyValuePairDto[]>(<any>null);
    }

    /**
     * @param type (optional) 
     * @param keyword (optional) 
     * @return Success
     */
    getPartialProductsByTypes(type: ProductSearchType | undefined, keyword: string | null | undefined): Observable<ProductSearchResultDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Production/GetPartialProductsByTypes?";
        if (type === null)
            throw new Error("The parameter 'type' cannot be null.");
        else if (type !== undefined)
            url_ += "type=" + encodeURIComponent("" + type) + "&";
        if (keyword !== undefined && keyword !== null)
            url_ += "keyword=" + encodeURIComponent("" + keyword) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPartialProductsByTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPartialProductsByTypes(<any>response_);
                } catch (e) {
                    return <Observable<ProductSearchResultDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProductSearchResultDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetPartialProductsByTypes(response: HttpResponseBase): Observable<ProductSearchResultDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ProductSearchResultDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductSearchResultDto[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createWarehouse(body: CreateWarehouseDto | undefined): Observable<WarehouseDto> {
        let url_ = this.baseUrl + "/api/services/app/Production/CreateWarehouse";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateWarehouse(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateWarehouse(<any>response_);
                } catch (e) {
                    return <Observable<WarehouseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<WarehouseDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateWarehouse(response: HttpResponseBase): Observable<WarehouseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WarehouseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WarehouseDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteWarehouse(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Production/DeleteWarehouse?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteWarehouse(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteWarehouse(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteWarehouse(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getWarehouse(id: string | undefined): Observable<WarehouseDto> {
        let url_ = this.baseUrl + "/api/services/app/Production/GetWarehouse?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWarehouse(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWarehouse(<any>response_);
                } catch (e) {
                    return <Observable<WarehouseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<WarehouseDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetWarehouse(response: HttpResponseBase): Observable<WarehouseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WarehouseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WarehouseDto>(<any>null);
    }

    /**
     * @param keyword (optional) 
     * @param isActive (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllWarehouses(keyword: string | null | undefined, isActive: boolean | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<WarehouseDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Production/GetAllWarehouses?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (isActive !== undefined && isActive !== null)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllWarehouses(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllWarehouses(<any>response_);
                } catch (e) {
                    return <Observable<WarehouseDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<WarehouseDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllWarehouses(response: HttpResponseBase): Observable<WarehouseDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WarehouseDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WarehouseDtoPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateWarehouse(body: UpdateWarehouseDto | undefined): Observable<WarehouseDto> {
        let url_ = this.baseUrl + "/api/services/app/Production/UpdateWarehouse";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateWarehouse(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateWarehouse(<any>response_);
                } catch (e) {
                    return <Observable<WarehouseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<WarehouseDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateWarehouse(response: HttpResponseBase): Observable<WarehouseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WarehouseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WarehouseDto>(<any>null);
    }

    /**
     * @return Success
     */
    getAllKeyValuePairWarehouses(): Observable<CommonKeyValuePairDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Production/GetAllKeyValuePairWarehouses";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllKeyValuePairWarehouses(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllKeyValuePairWarehouses(<any>response_);
                } catch (e) {
                    return <Observable<CommonKeyValuePairDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonKeyValuePairDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllKeyValuePairWarehouses(response: HttpResponseBase): Observable<CommonKeyValuePairDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(CommonKeyValuePairDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonKeyValuePairDto[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createCategory(body: CreateCategoryDto | undefined): Observable<CategoryDto> {
        let url_ = this.baseUrl + "/api/services/app/Production/CreateCategory";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateCategory(<any>response_);
                } catch (e) {
                    return <Observable<CategoryDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CategoryDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateCategory(response: HttpResponseBase): Observable<CategoryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CategoryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CategoryDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteCategory(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Production/DeleteCategory?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteCategory(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteCategory(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param keyword (optional) 
     * @param isActive (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllCategories(keyword: string | null | undefined, isActive: boolean | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<CategoryDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Production/GetAllCategories?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (isActive !== undefined && isActive !== null)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCategories(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCategories(<any>response_);
                } catch (e) {
                    return <Observable<CategoryDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CategoryDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllCategories(response: HttpResponseBase): Observable<CategoryDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CategoryDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CategoryDtoPagedResultDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getCategory(id: string | undefined): Observable<CategoryDto> {
        let url_ = this.baseUrl + "/api/services/app/Production/GetCategory?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCategory(<any>response_);
                } catch (e) {
                    return <Observable<CategoryDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CategoryDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetCategory(response: HttpResponseBase): Observable<CategoryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CategoryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CategoryDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateCategory(body: CategoryDto | undefined): Observable<CategoryDto> {
        let url_ = this.baseUrl + "/api/services/app/Production/UpdateCategory";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCategory(<any>response_);
                } catch (e) {
                    return <Observable<CategoryDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CategoryDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateCategory(response: HttpResponseBase): Observable<CategoryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CategoryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CategoryDto>(<any>null);
    }

    /**
     * @return Success
     */
    getAllCategoriesKeyValuePair(): Observable<CommonKeyValuePairDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Production/GetAllCategoriesKeyValuePair";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCategoriesKeyValuePair(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCategoriesKeyValuePair(<any>response_);
                } catch (e) {
                    return <Observable<CommonKeyValuePairDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonKeyValuePairDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllCategoriesKeyValuePair(response: HttpResponseBase): Observable<CommonKeyValuePairDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(CommonKeyValuePairDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonKeyValuePairDto[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createBrand(body: CreateBrandDto | undefined): Observable<BrandDto> {
        let url_ = this.baseUrl + "/api/services/app/Production/CreateBrand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateBrand(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateBrand(<any>response_);
                } catch (e) {
                    return <Observable<BrandDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<BrandDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateBrand(response: HttpResponseBase): Observable<BrandDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BrandDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BrandDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteBrand(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Production/DeleteBrand?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteBrand(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteBrand(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteBrand(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param keyword (optional) 
     * @param isActive (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllBrands(keyword: string | null | undefined, isActive: boolean | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<BrandDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Production/GetAllBrands?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (isActive !== undefined && isActive !== null)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllBrands(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllBrands(<any>response_);
                } catch (e) {
                    return <Observable<BrandDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<BrandDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllBrands(response: HttpResponseBase): Observable<BrandDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BrandDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BrandDtoPagedResultDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getBrand(id: string | undefined): Observable<BrandDto> {
        let url_ = this.baseUrl + "/api/services/app/Production/GetBrand?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBrand(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBrand(<any>response_);
                } catch (e) {
                    return <Observable<BrandDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<BrandDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetBrand(response: HttpResponseBase): Observable<BrandDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BrandDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BrandDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateBrand(body: BrandDto | undefined): Observable<BrandDto> {
        let url_ = this.baseUrl + "/api/services/app/Production/UpdateBrand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateBrand(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateBrand(<any>response_);
                } catch (e) {
                    return <Observable<BrandDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<BrandDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateBrand(response: HttpResponseBase): Observable<BrandDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BrandDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BrandDto>(<any>null);
    }

    /**
     * @return Success
     */
    getAllBrandsKeyValuePair(): Observable<CommonKeyValuePairDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Production/GetAllBrandsKeyValuePair";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllBrandsKeyValuePair(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllBrandsKeyValuePair(<any>response_);
                } catch (e) {
                    return <Observable<CommonKeyValuePairDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonKeyValuePairDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllBrandsKeyValuePair(response: HttpResponseBase): Observable<CommonKeyValuePairDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(CommonKeyValuePairDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonKeyValuePairDto[]>(<any>null);
    }

    /**
     * @param productId (optional) 
     * @return Success
     */
    getStockBalancesByProductId(productId: string | undefined): Observable<ProductStockBalanceDtoResponseDto> {
        let url_ = this.baseUrl + "/api/services/app/Production/GetStockBalancesByProductId?";
        if (productId === null)
            throw new Error("The parameter 'productId' cannot be null.");
        else if (productId !== undefined)
            url_ += "productId=" + encodeURIComponent("" + productId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStockBalancesByProductId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStockBalancesByProductId(<any>response_);
                } catch (e) {
                    return <Observable<ProductStockBalanceDtoResponseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProductStockBalanceDtoResponseDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetStockBalancesByProductId(response: HttpResponseBase): Observable<ProductStockBalanceDtoResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductStockBalanceDtoResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductStockBalanceDtoResponseDto>(<any>null);
    }

    /**
     * @param productId (optional) 
     * @return Success
     */
    getRecentlyCreatedGoodsReceivedNote(productId: string | undefined): Observable<ProductStockBalanceDto> {
        let url_ = this.baseUrl + "/api/services/app/Production/GetRecentlyCreatedGoodsReceivedNote?";
        if (productId === null)
            throw new Error("The parameter 'productId' cannot be null.");
        else if (productId !== undefined)
            url_ += "productId=" + encodeURIComponent("" + productId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRecentlyCreatedGoodsReceivedNote(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRecentlyCreatedGoodsReceivedNote(<any>response_);
                } catch (e) {
                    return <Observable<ProductStockBalanceDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProductStockBalanceDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetRecentlyCreatedGoodsReceivedNote(response: HttpResponseBase): Observable<ProductStockBalanceDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductStockBalanceDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductStockBalanceDto>(<any>null);
    }
}

@Injectable()
export class PurchasingServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createSupplier(body: CreateSupplierDto | undefined): Observable<SupplierDto> {
        let url_ = this.baseUrl + "/api/services/app/Purchasing/CreateSupplier";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateSupplier(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateSupplier(<any>response_);
                } catch (e) {
                    return <Observable<SupplierDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SupplierDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateSupplier(response: HttpResponseBase): Observable<SupplierDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SupplierDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SupplierDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteSupplier(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Purchasing/DeleteSupplier?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteSupplier(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteSupplier(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteSupplier(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param keyword (optional) 
     * @param isActive (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllSuppliers(keyword: string | null | undefined, isActive: boolean | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<SupplierDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Purchasing/GetAllSuppliers?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (isActive !== undefined && isActive !== null)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSuppliers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSuppliers(<any>response_);
                } catch (e) {
                    return <Observable<SupplierDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SupplierDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllSuppliers(response: HttpResponseBase): Observable<SupplierDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SupplierDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SupplierDtoPagedResultDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getSupplier(id: string | undefined): Observable<SupplierDto> {
        let url_ = this.baseUrl + "/api/services/app/Purchasing/GetSupplier?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSupplier(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSupplier(<any>response_);
                } catch (e) {
                    return <Observable<SupplierDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SupplierDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetSupplier(response: HttpResponseBase): Observable<SupplierDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SupplierDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SupplierDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateSupplier(body: SupplierDto | undefined): Observable<SupplierDto> {
        let url_ = this.baseUrl + "/api/services/app/Purchasing/UpdateSupplier";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateSupplier(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateSupplier(<any>response_);
                } catch (e) {
                    return <Observable<SupplierDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SupplierDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateSupplier(response: HttpResponseBase): Observable<SupplierDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SupplierDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SupplierDto>(<any>null);
    }

    /**
     * @param keyword (optional) 
     * @return Success
     */
    getPartialSuppliers(keyword: string | null | undefined): Observable<CommonKeyValuePairDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Purchasing/GetPartialSuppliers?";
        if (keyword !== undefined && keyword !== null)
            url_ += "keyword=" + encodeURIComponent("" + keyword) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPartialSuppliers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPartialSuppliers(<any>response_);
                } catch (e) {
                    return <Observable<CommonKeyValuePairDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonKeyValuePairDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetPartialSuppliers(response: HttpResponseBase): Observable<CommonKeyValuePairDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(CommonKeyValuePairDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonKeyValuePairDto[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createPurchaseOrder(body: CreatePurchaseOrderDto | undefined): Observable<PurchaseOrderDto> {
        let url_ = this.baseUrl + "/api/services/app/Purchasing/CreatePurchaseOrder";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreatePurchaseOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreatePurchaseOrder(<any>response_);
                } catch (e) {
                    return <Observable<PurchaseOrderDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PurchaseOrderDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreatePurchaseOrder(response: HttpResponseBase): Observable<PurchaseOrderDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PurchaseOrderDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PurchaseOrderDto>(<any>null);
    }
}

@Injectable()
export class RoleServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateRoleDto | undefined): Observable<RoleDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<RoleDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RoleDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<RoleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleDto>(<any>null);
    }

    /**
     * @param permission (optional) 
     * @return Success
     */
    getRoles(permission: string | null | undefined): Observable<RoleListDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetRoles?";
        if (permission !== undefined && permission !== null)
            url_ += "Permission=" + encodeURIComponent("" + permission) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoles(<any>response_);
                } catch (e) {
                    return <Observable<RoleListDtoListResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RoleListDtoListResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetRoles(response: HttpResponseBase): Observable<RoleListDtoListResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleListDtoListResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleListDtoListResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: RoleDto | undefined): Observable<RoleDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<RoleDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RoleDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<RoleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Role/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getAllPermissions(): Observable<PermissionDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetAllPermissions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPermissions(<any>response_);
                } catch (e) {
                    return <Observable<PermissionDtoListResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PermissionDtoListResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllPermissions(response: HttpResponseBase): Observable<PermissionDtoListResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PermissionDtoListResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PermissionDtoListResultDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getRoleForEdit(id: number | undefined): Observable<GetRoleForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetRoleForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoleForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoleForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetRoleForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetRoleForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetRoleForEdit(response: HttpResponseBase): Observable<GetRoleForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetRoleForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetRoleForEditOutput>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<RoleDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<RoleDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RoleDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<RoleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleDto>(<any>null);
    }

    /**
     * @param keyword (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<RoleDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetAll?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<RoleDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RoleDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<RoleDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleDtoPagedResultDto>(<any>null);
    }
}

@Injectable()
export class SalesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createCustomer(body: CreateCustomerDto | undefined): Observable<CustomerDto> {
        let url_ = this.baseUrl + "/api/services/app/Sales/CreateCustomer";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateCustomer(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateCustomer(<any>response_);
                } catch (e) {
                    return <Observable<CustomerDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CustomerDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateCustomer(response: HttpResponseBase): Observable<CustomerDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CustomerDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CustomerDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteCustomer(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Sales/DeleteCustomer?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteCustomer(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteCustomer(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteCustomer(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param keyword (optional) 
     * @param isActive (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllCustomers(keyword: string | null | undefined, isActive: boolean | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<CustomerDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Sales/GetAllCustomers?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (isActive !== undefined && isActive !== null)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCustomers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCustomers(<any>response_);
                } catch (e) {
                    return <Observable<CustomerDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CustomerDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllCustomers(response: HttpResponseBase): Observable<CustomerDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CustomerDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CustomerDtoPagedResultDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getCustomer(id: string | undefined): Observable<CustomerDto> {
        let url_ = this.baseUrl + "/api/services/app/Sales/GetCustomer?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCustomer(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCustomer(<any>response_);
                } catch (e) {
                    return <Observable<CustomerDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CustomerDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetCustomer(response: HttpResponseBase): Observable<CustomerDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CustomerDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CustomerDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateCustomer(body: CustomerDto | undefined): Observable<CustomerDto> {
        let url_ = this.baseUrl + "/api/services/app/Sales/UpdateCustomer";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCustomer(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCustomer(<any>response_);
                } catch (e) {
                    return <Observable<CustomerDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CustomerDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateCustomer(response: HttpResponseBase): Observable<CustomerDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CustomerDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CustomerDto>(<any>null);
    }

    /**
     * @param keyword (optional) 
     * @return Success
     */
    getPartialCustomers(keyword: string | null | undefined): Observable<CommonKeyValuePairDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Sales/GetPartialCustomers?";
        if (keyword !== undefined && keyword !== null)
            url_ += "keyword=" + encodeURIComponent("" + keyword) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPartialCustomers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPartialCustomers(<any>response_);
                } catch (e) {
                    return <Observable<CommonKeyValuePairDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonKeyValuePairDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetPartialCustomers(response: HttpResponseBase): Observable<CommonKeyValuePairDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(CommonKeyValuePairDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonKeyValuePairDto[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrUpdateTempSales(body: CreateOrUpdateTempSaleDto | undefined): Observable<TempSaleDto> {
        let url_ = this.baseUrl + "/api/services/app/Sales/CreateOrUpdateTempSales";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateTempSales(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateTempSales(<any>response_);
                } catch (e) {
                    return <Observable<TempSaleDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TempSaleDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdateTempSales(response: HttpResponseBase): Observable<TempSaleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TempSaleDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TempSaleDto>(<any>null);
    }

    /**
     * @param tempSaleId (optional) 
     * @return Success
     */
    getTempSales(tempSaleId: number | undefined): Observable<TempSaleDto> {
        let url_ = this.baseUrl + "/api/services/app/Sales/GetTempSales?";
        if (tempSaleId === null)
            throw new Error("The parameter 'tempSaleId' cannot be null.");
        else if (tempSaleId !== undefined)
            url_ += "tempSaleId=" + encodeURIComponent("" + tempSaleId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTempSales(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTempSales(<any>response_);
                } catch (e) {
                    return <Observable<TempSaleDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TempSaleDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetTempSales(response: HttpResponseBase): Observable<TempSaleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TempSaleDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TempSaleDto>(<any>null);
    }

    /**
     * @param stockBalanceIds (optional) 
     * @return Success
     */
    getStockBalancesByStockBalanceIds(stockBalanceIds: string[] | null | undefined): Observable<ProductStockBalanceDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Sales/GetStockBalancesByStockBalanceIds?";
        if (stockBalanceIds !== undefined && stockBalanceIds !== null)
            stockBalanceIds && stockBalanceIds.forEach(item => { url_ += "stockBalanceIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStockBalancesByStockBalanceIds(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStockBalancesByStockBalanceIds(<any>response_);
                } catch (e) {
                    return <Observable<ProductStockBalanceDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProductStockBalanceDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetStockBalancesByStockBalanceIds(response: HttpResponseBase): Observable<ProductStockBalanceDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ProductStockBalanceDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductStockBalanceDto[]>(<any>null);
    }

    /**
     * @param tempSaleId (optional) 
     * @return Success
     */
    getNonInventoryProductByTempSaleId(tempSaleId: number | undefined): Observable<NonInventoryProductDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Sales/GetNonInventoryProductByTempSaleId?";
        if (tempSaleId === null)
            throw new Error("The parameter 'tempSaleId' cannot be null.");
        else if (tempSaleId !== undefined)
            url_ += "tempSaleId=" + encodeURIComponent("" + tempSaleId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNonInventoryProductByTempSaleId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNonInventoryProductByTempSaleId(<any>response_);
                } catch (e) {
                    return <Observable<NonInventoryProductDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<NonInventoryProductDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetNonInventoryProductByTempSaleId(response: HttpResponseBase): Observable<NonInventoryProductDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(NonInventoryProductDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NonInventoryProductDto[]>(<any>null);
    }
}

@Injectable()
export class SessionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getCurrentLoginInformations(): Observable<GetCurrentLoginInformationsOutput> {
        let url_ = this.baseUrl + "/api/services/app/Session/GetCurrentLoginInformations";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrentLoginInformations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrentLoginInformations(<any>response_);
                } catch (e) {
                    return <Observable<GetCurrentLoginInformationsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetCurrentLoginInformationsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetCurrentLoginInformations(response: HttpResponseBase): Observable<GetCurrentLoginInformationsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetCurrentLoginInformationsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCurrentLoginInformationsOutput>(<any>null);
    }
}

@Injectable()
export class TenantServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateTenantDto | undefined): Observable<TenantDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<TenantDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TenantDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<TenantDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TenantDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<TenantDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<TenantDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TenantDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<TenantDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TenantDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantDto>(<any>null);
    }

    /**
     * @param keyword (optional) 
     * @param isActive (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, isActive: boolean | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<TenantDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/GetAll?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (isActive !== undefined && isActive !== null)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<TenantDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TenantDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<TenantDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TenantDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantDtoPagedResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: TenantDto | undefined): Observable<TenantDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<TenantDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TenantDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<TenantDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TenantDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantDto>(<any>null);
    }
}

@Injectable()
export class TokenAuthServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    authenticate(body: AuthenticateModel | undefined): Observable<AuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/Authenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuthenticate(<any>response_);
                } catch (e) {
                    return <Observable<AuthenticateResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<AuthenticateResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processAuthenticate(response: HttpResponseBase): Observable<AuthenticateResultModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthenticateResultModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AuthenticateResultModel>(<any>null);
    }

    /**
     * @return Success
     */
    getExternalAuthenticationProviders(): Observable<ExternalLoginProviderInfoModel[]> {
        let url_ = this.baseUrl + "/api/TokenAuth/GetExternalAuthenticationProviders";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetExternalAuthenticationProviders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetExternalAuthenticationProviders(<any>response_);
                } catch (e) {
                    return <Observable<ExternalLoginProviderInfoModel[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ExternalLoginProviderInfoModel[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetExternalAuthenticationProviders(response: HttpResponseBase): Observable<ExternalLoginProviderInfoModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ExternalLoginProviderInfoModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExternalLoginProviderInfoModel[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    externalAuthenticate(body: ExternalAuthenticateModel | undefined): Observable<ExternalAuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/ExternalAuthenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExternalAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExternalAuthenticate(<any>response_);
                } catch (e) {
                    return <Observable<ExternalAuthenticateResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ExternalAuthenticateResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processExternalAuthenticate(response: HttpResponseBase): Observable<ExternalAuthenticateResultModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExternalAuthenticateResultModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExternalAuthenticateResultModel>(<any>null);
    }
}

@Injectable()
export class UserServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateUserDto | undefined): Observable<UserDto> {
        let url_ = this.baseUrl + "/api/services/app/User/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<UserDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<UserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UserDto | undefined): Observable<UserDto> {
        let url_ = this.baseUrl + "/api/services/app/User/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<UserDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<UserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    activate(body: Int64EntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/Activate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActivate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActivate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processActivate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    deActivate(body: Int64EntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/DeActivate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeActivate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeActivate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeActivate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getRoles(): Observable<RoleDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/User/GetRoles";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoles(<any>response_);
                } catch (e) {
                    return <Observable<RoleDtoListResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RoleDtoListResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetRoles(response: HttpResponseBase): Observable<RoleDtoListResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleDtoListResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleDtoListResultDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changeLanguage(body: ChangeUserLanguageDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/ChangeLanguage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeLanguage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeLanguage(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processChangeLanguage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changePassword(body: ChangePasswordDto | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/User/ChangePassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangePassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangePassword(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processChangePassword(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    resetPassword(body: ResetPasswordDto | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/User/ResetPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetPassword(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processResetPassword(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<UserDto> {
        let url_ = this.baseUrl + "/api/services/app/User/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<UserDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<UserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDto>(<any>null);
    }

    /**
     * @param keyword (optional) 
     * @param isActive (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, isActive: boolean | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<UserDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/User/GetAll?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (isActive !== undefined && isActive !== null)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<UserDtoPagedResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserDtoPagedResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<UserDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDtoPagedResultDto>(<any>null);
    }
}

export class IsTenantAvailableInput implements IIsTenantAvailableInput {
    tenancyName: string;

    constructor(data?: IIsTenantAvailableInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenancyName = _data["tenancyName"];
        }
    }

    static fromJS(data: any): IsTenantAvailableInput {
        data = typeof data === 'object' ? data : {};
        let result = new IsTenantAvailableInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        return data; 
    }

    clone(): IsTenantAvailableInput {
        const json = this.toJSON();
        let result = new IsTenantAvailableInput();
        result.init(json);
        return result;
    }
}

export interface IIsTenantAvailableInput {
    tenancyName: string;
}

export enum TenantAvailabilityState {
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export class IsTenantAvailableOutput implements IIsTenantAvailableOutput {
    state: TenantAvailabilityState;
    tenantId: number | undefined;

    constructor(data?: IIsTenantAvailableOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.state = _data["state"];
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): IsTenantAvailableOutput {
        data = typeof data === 'object' ? data : {};
        let result = new IsTenantAvailableOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["state"] = this.state;
        data["tenantId"] = this.tenantId;
        return data; 
    }

    clone(): IsTenantAvailableOutput {
        const json = this.toJSON();
        let result = new IsTenantAvailableOutput();
        result.init(json);
        return result;
    }
}

export interface IIsTenantAvailableOutput {
    state: TenantAvailabilityState;
    tenantId: number | undefined;
}

export class RegisterInput implements IRegisterInput {
    name: string;
    surname: string;
    userName: string;
    emailAddress: string;
    password: string;
    captchaResponse: string | undefined;

    constructor(data?: IRegisterInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.userName = _data["userName"];
            this.emailAddress = _data["emailAddress"];
            this.password = _data["password"];
            this.captchaResponse = _data["captchaResponse"];
        }
    }

    static fromJS(data: any): RegisterInput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["password"] = this.password;
        data["captchaResponse"] = this.captchaResponse;
        return data; 
    }

    clone(): RegisterInput {
        const json = this.toJSON();
        let result = new RegisterInput();
        result.init(json);
        return result;
    }
}

export interface IRegisterInput {
    name: string;
    surname: string;
    userName: string;
    emailAddress: string;
    password: string;
    captchaResponse: string | undefined;
}

export class RegisterOutput implements IRegisterOutput {
    canLogin: boolean;

    constructor(data?: IRegisterOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.canLogin = _data["canLogin"];
        }
    }

    static fromJS(data: any): RegisterOutput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["canLogin"] = this.canLogin;
        return data; 
    }

    clone(): RegisterOutput {
        const json = this.toJSON();
        let result = new RegisterOutput();
        result.init(json);
        return result;
    }
}

export interface IRegisterOutput {
    canLogin: boolean;
}

export class CommonKeyValuePairDto implements ICommonKeyValuePairDto {
    id: string;
    code: string | undefined;
    name: string | undefined;

    constructor(data?: ICommonKeyValuePairDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CommonKeyValuePairDto {
        data = typeof data === 'object' ? data : {};
        let result = new CommonKeyValuePairDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["name"] = this.name;
        return data; 
    }

    clone(): CommonKeyValuePairDto {
        const json = this.toJSON();
        let result = new CommonKeyValuePairDto();
        result.init(json);
        return result;
    }
}

export interface ICommonKeyValuePairDto {
    id: string;
    code: string | undefined;
    name: string | undefined;
}

export class ChangeUiThemeInput implements IChangeUiThemeInput {
    theme: string;

    constructor(data?: IChangeUiThemeInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.theme = _data["theme"];
        }
    }

    static fromJS(data: any): ChangeUiThemeInput {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeUiThemeInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["theme"] = this.theme;
        return data; 
    }

    clone(): ChangeUiThemeInput {
        const json = this.toJSON();
        let result = new ChangeUiThemeInput();
        result.init(json);
        return result;
    }
}

export interface IChangeUiThemeInput {
    theme: string;
}

export enum DocumentType {
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
    _7 = 7,
    _8 = 8,
    _9 = 9,
    _10 = 10,
}

export class CashDto implements ICashDto {
    cashAmount: number;

    constructor(data?: ICashDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.cashAmount = _data["cashAmount"];
        }
    }

    static fromJS(data: any): CashDto {
        data = typeof data === 'object' ? data : {};
        let result = new CashDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cashAmount"] = this.cashAmount;
        return data; 
    }

    clone(): CashDto {
        const json = this.toJSON();
        let result = new CashDto();
        result.init(json);
        return result;
    }
}

export interface ICashDto {
    cashAmount: number;
}

export class ChequeDto implements IChequeDto {
    chequeNumber: string | undefined;
    bankId: string;
    bank: string | undefined;
    branchId: string | undefined;
    branch: string | undefined;
    chequeReturnDate: moment.Moment;
    chequeAmount: number;

    constructor(data?: IChequeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.chequeNumber = _data["chequeNumber"];
            this.bankId = _data["bankId"];
            this.bank = _data["bank"];
            this.branchId = _data["branchId"];
            this.branch = _data["branch"];
            this.chequeReturnDate = _data["chequeReturnDate"] ? moment(_data["chequeReturnDate"].toString()) : <any>undefined;
            this.chequeAmount = _data["chequeAmount"];
        }
    }

    static fromJS(data: any): ChequeDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChequeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["chequeNumber"] = this.chequeNumber;
        data["bankId"] = this.bankId;
        data["bank"] = this.bank;
        data["branchId"] = this.branchId;
        data["branch"] = this.branch;
        data["chequeReturnDate"] = this.chequeReturnDate ? this.chequeReturnDate.toISOString() : <any>undefined;
        data["chequeAmount"] = this.chequeAmount;
        return data; 
    }

    clone(): ChequeDto {
        const json = this.toJSON();
        let result = new ChequeDto();
        result.init(json);
        return result;
    }
}

export interface IChequeDto {
    chequeNumber: string | undefined;
    bankId: string;
    bank: string | undefined;
    branchId: string | undefined;
    branch: string | undefined;
    chequeReturnDate: moment.Moment;
    chequeAmount: number;
}

export class CustomerCreditOutstandingDto implements ICustomerCreditOutstandingDto {
    outstandingAmount: number;

    constructor(data?: ICustomerCreditOutstandingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.outstandingAmount = _data["outstandingAmount"];
        }
    }

    static fromJS(data: any): CustomerCreditOutstandingDto {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerCreditOutstandingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["outstandingAmount"] = this.outstandingAmount;
        return data; 
    }

    clone(): CustomerCreditOutstandingDto {
        const json = this.toJSON();
        let result = new CustomerCreditOutstandingDto();
        result.init(json);
        return result;
    }
}

export interface ICustomerCreditOutstandingDto {
    outstandingAmount: number;
}

export class DebitCardDto implements IDebitCardDto {

    constructor(data?: IDebitCardDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): DebitCardDto {
        data = typeof data === 'object' ? data : {};
        let result = new DebitCardDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }

    clone(): DebitCardDto {
        const json = this.toJSON();
        let result = new DebitCardDto();
        result.init(json);
        return result;
    }
}

export interface IDebitCardDto {
}

export class GiftCardDto implements IGiftCardDto {
    giftCardAmount: number;

    constructor(data?: IGiftCardDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.giftCardAmount = _data["giftCardAmount"];
        }
    }

    static fromJS(data: any): GiftCardDto {
        data = typeof data === 'object' ? data : {};
        let result = new GiftCardDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["giftCardAmount"] = this.giftCardAmount;
        return data; 
    }

    clone(): GiftCardDto {
        const json = this.toJSON();
        let result = new GiftCardDto();
        result.init(json);
        return result;
    }
}

export interface IGiftCardDto {
    giftCardAmount: number;
}

export class CreateInvoiceDto implements ICreateInvoiceDto {
    tempSaleId: number | undefined;
    customerId: string | undefined;
    customerCode: string | undefined;
    customerName: string | undefined;
    discountRate: number;
    discountAmount: number;
    taxRate: number;
    taxAmount: number;
    grossAmount: number;
    netAmount: number;
    cashes: CashDto[] | undefined;
    cheques: ChequeDto[] | undefined;
    outstandings: CustomerCreditOutstandingDto[] | undefined;
    debitCards: DebitCardDto[] | undefined;
    giftCards: GiftCardDto[] | undefined;

    constructor(data?: ICreateInvoiceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tempSaleId = _data["tempSaleId"];
            this.customerId = _data["customerId"];
            this.customerCode = _data["customerCode"];
            this.customerName = _data["customerName"];
            this.discountRate = _data["discountRate"];
            this.discountAmount = _data["discountAmount"];
            this.taxRate = _data["taxRate"];
            this.taxAmount = _data["taxAmount"];
            this.grossAmount = _data["grossAmount"];
            this.netAmount = _data["netAmount"];
            if (Array.isArray(_data["cashes"])) {
                this.cashes = [] as any;
                for (let item of _data["cashes"])
                    this.cashes.push(CashDto.fromJS(item));
            }
            if (Array.isArray(_data["cheques"])) {
                this.cheques = [] as any;
                for (let item of _data["cheques"])
                    this.cheques.push(ChequeDto.fromJS(item));
            }
            if (Array.isArray(_data["outstandings"])) {
                this.outstandings = [] as any;
                for (let item of _data["outstandings"])
                    this.outstandings.push(CustomerCreditOutstandingDto.fromJS(item));
            }
            if (Array.isArray(_data["debitCards"])) {
                this.debitCards = [] as any;
                for (let item of _data["debitCards"])
                    this.debitCards.push(DebitCardDto.fromJS(item));
            }
            if (Array.isArray(_data["giftCards"])) {
                this.giftCards = [] as any;
                for (let item of _data["giftCards"])
                    this.giftCards.push(GiftCardDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateInvoiceDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateInvoiceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tempSaleId"] = this.tempSaleId;
        data["customerId"] = this.customerId;
        data["customerCode"] = this.customerCode;
        data["customerName"] = this.customerName;
        data["discountRate"] = this.discountRate;
        data["discountAmount"] = this.discountAmount;
        data["taxRate"] = this.taxRate;
        data["taxAmount"] = this.taxAmount;
        data["grossAmount"] = this.grossAmount;
        data["netAmount"] = this.netAmount;
        if (Array.isArray(this.cashes)) {
            data["cashes"] = [];
            for (let item of this.cashes)
                data["cashes"].push(item.toJSON());
        }
        if (Array.isArray(this.cheques)) {
            data["cheques"] = [];
            for (let item of this.cheques)
                data["cheques"].push(item.toJSON());
        }
        if (Array.isArray(this.outstandings)) {
            data["outstandings"] = [];
            for (let item of this.outstandings)
                data["outstandings"].push(item.toJSON());
        }
        if (Array.isArray(this.debitCards)) {
            data["debitCards"] = [];
            for (let item of this.debitCards)
                data["debitCards"].push(item.toJSON());
        }
        if (Array.isArray(this.giftCards)) {
            data["giftCards"] = [];
            for (let item of this.giftCards)
                data["giftCards"].push(item.toJSON());
        }
        return data; 
    }

    clone(): CreateInvoiceDto {
        const json = this.toJSON();
        let result = new CreateInvoiceDto();
        result.init(json);
        return result;
    }
}

export interface ICreateInvoiceDto {
    tempSaleId: number | undefined;
    customerId: string | undefined;
    customerCode: string | undefined;
    customerName: string | undefined;
    discountRate: number;
    discountAmount: number;
    taxRate: number;
    taxAmount: number;
    grossAmount: number;
    netAmount: number;
    cashes: CashDto[] | undefined;
    cheques: ChequeDto[] | undefined;
    outstandings: CustomerCreditOutstandingDto[] | undefined;
    debitCards: DebitCardDto[] | undefined;
    giftCards: GiftCardDto[] | undefined;
}

export class InvoiceProductDto implements IInvoiceProductDto {
    invoiceId: string;
    invoiceNumber: string | undefined;
    stockBalanceId: string;
    productId: string;
    productCode: string;
    productName: string;
    warehouseId: string;
    warehouseCode: string | undefined;
    warehouseName: string | undefined;
    costPrice: number;
    sellingPrice: number;
    maximumRetailPrice: number;
    quantity: number;
    price: number;
    discountRate: number;
    discountAmount: number;
    lineTotal: number;
    remarks: string | undefined;
    id: string;

    constructor(data?: IInvoiceProductDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.invoiceId = _data["invoiceId"];
            this.invoiceNumber = _data["invoiceNumber"];
            this.stockBalanceId = _data["stockBalanceId"];
            this.productId = _data["productId"];
            this.productCode = _data["productCode"];
            this.productName = _data["productName"];
            this.warehouseId = _data["warehouseId"];
            this.warehouseCode = _data["warehouseCode"];
            this.warehouseName = _data["warehouseName"];
            this.costPrice = _data["costPrice"];
            this.sellingPrice = _data["sellingPrice"];
            this.maximumRetailPrice = _data["maximumRetailPrice"];
            this.quantity = _data["quantity"];
            this.price = _data["price"];
            this.discountRate = _data["discountRate"];
            this.discountAmount = _data["discountAmount"];
            this.lineTotal = _data["lineTotal"];
            this.remarks = _data["remarks"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): InvoiceProductDto {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceProductDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["invoiceId"] = this.invoiceId;
        data["invoiceNumber"] = this.invoiceNumber;
        data["stockBalanceId"] = this.stockBalanceId;
        data["productId"] = this.productId;
        data["productCode"] = this.productCode;
        data["productName"] = this.productName;
        data["warehouseId"] = this.warehouseId;
        data["warehouseCode"] = this.warehouseCode;
        data["warehouseName"] = this.warehouseName;
        data["costPrice"] = this.costPrice;
        data["sellingPrice"] = this.sellingPrice;
        data["maximumRetailPrice"] = this.maximumRetailPrice;
        data["quantity"] = this.quantity;
        data["price"] = this.price;
        data["discountRate"] = this.discountRate;
        data["discountAmount"] = this.discountAmount;
        data["lineTotal"] = this.lineTotal;
        data["remarks"] = this.remarks;
        data["id"] = this.id;
        return data; 
    }

    clone(): InvoiceProductDto {
        const json = this.toJSON();
        let result = new InvoiceProductDto();
        result.init(json);
        return result;
    }
}

export interface IInvoiceProductDto {
    invoiceId: string;
    invoiceNumber: string | undefined;
    stockBalanceId: string;
    productId: string;
    productCode: string;
    productName: string;
    warehouseId: string;
    warehouseCode: string | undefined;
    warehouseName: string | undefined;
    costPrice: number;
    sellingPrice: number;
    maximumRetailPrice: number;
    quantity: number;
    price: number;
    discountRate: number;
    discountAmount: number;
    lineTotal: number;
    remarks: string | undefined;
    id: string;
}

export class InvoiceDto implements IInvoiceDto {
    tempSaleId: number | undefined;
    invoiceNumber: string;
    referenceNumber: string | undefined;
    customerId: string | undefined;
    customerCode: string | undefined;
    customerName: string | undefined;
    discountRate: number;
    discountAmount: number;
    taxRate: number;
    taxAmount: number;
    grossAmount: number;
    netAmount: number;
    remarks: string | undefined;
    invoiceProducts: InvoiceProductDto[] | undefined;
    id: string;

    constructor(data?: IInvoiceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tempSaleId = _data["tempSaleId"];
            this.invoiceNumber = _data["invoiceNumber"];
            this.referenceNumber = _data["referenceNumber"];
            this.customerId = _data["customerId"];
            this.customerCode = _data["customerCode"];
            this.customerName = _data["customerName"];
            this.discountRate = _data["discountRate"];
            this.discountAmount = _data["discountAmount"];
            this.taxRate = _data["taxRate"];
            this.taxAmount = _data["taxAmount"];
            this.grossAmount = _data["grossAmount"];
            this.netAmount = _data["netAmount"];
            this.remarks = _data["remarks"];
            if (Array.isArray(_data["invoiceProducts"])) {
                this.invoiceProducts = [] as any;
                for (let item of _data["invoiceProducts"])
                    this.invoiceProducts.push(InvoiceProductDto.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): InvoiceDto {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tempSaleId"] = this.tempSaleId;
        data["invoiceNumber"] = this.invoiceNumber;
        data["referenceNumber"] = this.referenceNumber;
        data["customerId"] = this.customerId;
        data["customerCode"] = this.customerCode;
        data["customerName"] = this.customerName;
        data["discountRate"] = this.discountRate;
        data["discountAmount"] = this.discountAmount;
        data["taxRate"] = this.taxRate;
        data["taxAmount"] = this.taxAmount;
        data["grossAmount"] = this.grossAmount;
        data["netAmount"] = this.netAmount;
        data["remarks"] = this.remarks;
        if (Array.isArray(this.invoiceProducts)) {
            data["invoiceProducts"] = [];
            for (let item of this.invoiceProducts)
                data["invoiceProducts"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data; 
    }

    clone(): InvoiceDto {
        const json = this.toJSON();
        let result = new InvoiceDto();
        result.init(json);
        return result;
    }
}

export interface IInvoiceDto {
    tempSaleId: number | undefined;
    invoiceNumber: string;
    referenceNumber: string | undefined;
    customerId: string | undefined;
    customerCode: string | undefined;
    customerName: string | undefined;
    discountRate: number;
    discountAmount: number;
    taxRate: number;
    taxAmount: number;
    grossAmount: number;
    netAmount: number;
    remarks: string | undefined;
    invoiceProducts: InvoiceProductDto[] | undefined;
    id: string;
}

export enum TransactionStatus {
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
}

export class CreateGoodsReceivedProductDto implements ICreateGoodsReceivedProductDto {
    goodsRecievedNumber: string | undefined;
    sequenceNumber: number;
    productId: string;
    productCode: string;
    productName: string;
    warehouseId: string;
    warehouseCode: string;
    warehouseName: string;
    expiryDate: moment.Moment | undefined;
    batchNumber: string | undefined;
    quantity: number;
    freeQuantity: number;
    costPrice: number;
    sellingPrice: number;
    maximumRetailPrice: number;
    discountRate: number;
    discountAmount: number;
    lineTotal: number;

    constructor(data?: ICreateGoodsReceivedProductDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.goodsRecievedNumber = _data["goodsRecievedNumber"];
            this.sequenceNumber = _data["sequenceNumber"];
            this.productId = _data["productId"];
            this.productCode = _data["productCode"];
            this.productName = _data["productName"];
            this.warehouseId = _data["warehouseId"];
            this.warehouseCode = _data["warehouseCode"];
            this.warehouseName = _data["warehouseName"];
            this.expiryDate = _data["expiryDate"] ? moment(_data["expiryDate"].toString()) : <any>undefined;
            this.batchNumber = _data["batchNumber"];
            this.quantity = _data["quantity"];
            this.freeQuantity = _data["freeQuantity"];
            this.costPrice = _data["costPrice"];
            this.sellingPrice = _data["sellingPrice"];
            this.maximumRetailPrice = _data["maximumRetailPrice"];
            this.discountRate = _data["discountRate"];
            this.discountAmount = _data["discountAmount"];
            this.lineTotal = _data["lineTotal"];
        }
    }

    static fromJS(data: any): CreateGoodsReceivedProductDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateGoodsReceivedProductDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["goodsRecievedNumber"] = this.goodsRecievedNumber;
        data["sequenceNumber"] = this.sequenceNumber;
        data["productId"] = this.productId;
        data["productCode"] = this.productCode;
        data["productName"] = this.productName;
        data["warehouseId"] = this.warehouseId;
        data["warehouseCode"] = this.warehouseCode;
        data["warehouseName"] = this.warehouseName;
        data["expiryDate"] = this.expiryDate ? this.expiryDate.toISOString() : <any>undefined;
        data["batchNumber"] = this.batchNumber;
        data["quantity"] = this.quantity;
        data["freeQuantity"] = this.freeQuantity;
        data["costPrice"] = this.costPrice;
        data["sellingPrice"] = this.sellingPrice;
        data["maximumRetailPrice"] = this.maximumRetailPrice;
        data["discountRate"] = this.discountRate;
        data["discountAmount"] = this.discountAmount;
        data["lineTotal"] = this.lineTotal;
        return data; 
    }

    clone(): CreateGoodsReceivedProductDto {
        const json = this.toJSON();
        let result = new CreateGoodsReceivedProductDto();
        result.init(json);
        return result;
    }
}

export interface ICreateGoodsReceivedProductDto {
    goodsRecievedNumber: string | undefined;
    sequenceNumber: number;
    productId: string;
    productCode: string;
    productName: string;
    warehouseId: string;
    warehouseCode: string;
    warehouseName: string;
    expiryDate: moment.Moment | undefined;
    batchNumber: string | undefined;
    quantity: number;
    freeQuantity: number;
    costPrice: number;
    sellingPrice: number;
    maximumRetailPrice: number;
    discountRate: number;
    discountAmount: number;
    lineTotal: number;
}

export class CreateGoodsReceivedDto implements ICreateGoodsReceivedDto {
    goodsReceivedNumber: string;
    referenceNumber: string | undefined;
    supplierId: string;
    supplierCode: string | undefined;
    supplierName: string | undefined;
    discountRate: number;
    discountAmount: number;
    taxRate: number;
    taxAmount: number;
    grossAmount: number;
    netAmount: number;
    transactionStatus: TransactionStatus;
    remarks: string | undefined;
    goodsReceivedProducts: CreateGoodsReceivedProductDto[] | undefined;

    constructor(data?: ICreateGoodsReceivedDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.goodsReceivedNumber = _data["goodsReceivedNumber"];
            this.referenceNumber = _data["referenceNumber"];
            this.supplierId = _data["supplierId"];
            this.supplierCode = _data["supplierCode"];
            this.supplierName = _data["supplierName"];
            this.discountRate = _data["discountRate"];
            this.discountAmount = _data["discountAmount"];
            this.taxRate = _data["taxRate"];
            this.taxAmount = _data["taxAmount"];
            this.grossAmount = _data["grossAmount"];
            this.netAmount = _data["netAmount"];
            this.transactionStatus = _data["transactionStatus"];
            this.remarks = _data["remarks"];
            if (Array.isArray(_data["goodsReceivedProducts"])) {
                this.goodsReceivedProducts = [] as any;
                for (let item of _data["goodsReceivedProducts"])
                    this.goodsReceivedProducts.push(CreateGoodsReceivedProductDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateGoodsReceivedDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateGoodsReceivedDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["goodsReceivedNumber"] = this.goodsReceivedNumber;
        data["referenceNumber"] = this.referenceNumber;
        data["supplierId"] = this.supplierId;
        data["supplierCode"] = this.supplierCode;
        data["supplierName"] = this.supplierName;
        data["discountRate"] = this.discountRate;
        data["discountAmount"] = this.discountAmount;
        data["taxRate"] = this.taxRate;
        data["taxAmount"] = this.taxAmount;
        data["grossAmount"] = this.grossAmount;
        data["netAmount"] = this.netAmount;
        data["transactionStatus"] = this.transactionStatus;
        data["remarks"] = this.remarks;
        if (Array.isArray(this.goodsReceivedProducts)) {
            data["goodsReceivedProducts"] = [];
            for (let item of this.goodsReceivedProducts)
                data["goodsReceivedProducts"].push(item.toJSON());
        }
        return data; 
    }

    clone(): CreateGoodsReceivedDto {
        const json = this.toJSON();
        let result = new CreateGoodsReceivedDto();
        result.init(json);
        return result;
    }
}

export interface ICreateGoodsReceivedDto {
    goodsReceivedNumber: string;
    referenceNumber: string | undefined;
    supplierId: string;
    supplierCode: string | undefined;
    supplierName: string | undefined;
    discountRate: number;
    discountAmount: number;
    taxRate: number;
    taxAmount: number;
    grossAmount: number;
    netAmount: number;
    transactionStatus: TransactionStatus;
    remarks: string | undefined;
    goodsReceivedProducts: CreateGoodsReceivedProductDto[] | undefined;
}

export class GoodsReceivedDto implements IGoodsReceivedDto {
    goodsReceivedNumber: string;
    referenceNumber: string | undefined;
    supplierId: string;
    supplierCode: string | undefined;
    supplierName: string | undefined;
    discountRate: number;
    discountAmount: number;
    taxRate: number;
    taxAmount: number;
    grossAmount: number;
    netAmount: number;
    transactionStatus: TransactionStatus;
    remarks: string | undefined;
    id: string;

    constructor(data?: IGoodsReceivedDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.goodsReceivedNumber = _data["goodsReceivedNumber"];
            this.referenceNumber = _data["referenceNumber"];
            this.supplierId = _data["supplierId"];
            this.supplierCode = _data["supplierCode"];
            this.supplierName = _data["supplierName"];
            this.discountRate = _data["discountRate"];
            this.discountAmount = _data["discountAmount"];
            this.taxRate = _data["taxRate"];
            this.taxAmount = _data["taxAmount"];
            this.grossAmount = _data["grossAmount"];
            this.netAmount = _data["netAmount"];
            this.transactionStatus = _data["transactionStatus"];
            this.remarks = _data["remarks"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): GoodsReceivedDto {
        data = typeof data === 'object' ? data : {};
        let result = new GoodsReceivedDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["goodsReceivedNumber"] = this.goodsReceivedNumber;
        data["referenceNumber"] = this.referenceNumber;
        data["supplierId"] = this.supplierId;
        data["supplierCode"] = this.supplierCode;
        data["supplierName"] = this.supplierName;
        data["discountRate"] = this.discountRate;
        data["discountAmount"] = this.discountAmount;
        data["taxRate"] = this.taxRate;
        data["taxAmount"] = this.taxAmount;
        data["grossAmount"] = this.grossAmount;
        data["netAmount"] = this.netAmount;
        data["transactionStatus"] = this.transactionStatus;
        data["remarks"] = this.remarks;
        data["id"] = this.id;
        return data; 
    }

    clone(): GoodsReceivedDto {
        const json = this.toJSON();
        let result = new GoodsReceivedDto();
        result.init(json);
        return result;
    }
}

export interface IGoodsReceivedDto {
    goodsReceivedNumber: string;
    referenceNumber: string | undefined;
    supplierId: string;
    supplierCode: string | undefined;
    supplierName: string | undefined;
    discountRate: number;
    discountAmount: number;
    taxRate: number;
    taxAmount: number;
    grossAmount: number;
    netAmount: number;
    transactionStatus: TransactionStatus;
    remarks: string | undefined;
    id: string;
}

export class GoodsReceivedDtoPagedResultDto implements IGoodsReceivedDtoPagedResultDto {
    totalCount: number;
    items: GoodsReceivedDto[] | undefined;

    constructor(data?: IGoodsReceivedDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(GoodsReceivedDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GoodsReceivedDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new GoodsReceivedDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): GoodsReceivedDtoPagedResultDto {
        const json = this.toJSON();
        let result = new GoodsReceivedDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IGoodsReceivedDtoPagedResultDto {
    totalCount: number;
    items: GoodsReceivedDto[] | undefined;
}

export class CreateProductDto implements ICreateProductDto {
    code: string;
    name: string;
    description: string | undefined;
    brandId: string | undefined;
    categoryId: string | undefined;
    barCode: string | undefined;
    packSize: number | undefined;
    reOrderLevel: number;
    discountRate: number | undefined;
    reOrderQuantity: number;
    costPrice: number;
    retailPrice: number;
    wholeSalePrice: number;
    isActive: boolean;
    supplierIds: string[] | undefined;

    constructor(data?: ICreateProductDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.brandId = _data["brandId"];
            this.categoryId = _data["categoryId"];
            this.barCode = _data["barCode"];
            this.packSize = _data["packSize"];
            this.reOrderLevel = _data["reOrderLevel"];
            this.discountRate = _data["discountRate"];
            this.reOrderQuantity = _data["reOrderQuantity"];
            this.costPrice = _data["costPrice"];
            this.retailPrice = _data["retailPrice"];
            this.wholeSalePrice = _data["wholeSalePrice"];
            this.isActive = _data["isActive"];
            if (Array.isArray(_data["supplierIds"])) {
                this.supplierIds = [] as any;
                for (let item of _data["supplierIds"])
                    this.supplierIds.push(item);
            }
        }
    }

    static fromJS(data: any): CreateProductDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProductDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["name"] = this.name;
        data["description"] = this.description;
        data["brandId"] = this.brandId;
        data["categoryId"] = this.categoryId;
        data["barCode"] = this.barCode;
        data["packSize"] = this.packSize;
        data["reOrderLevel"] = this.reOrderLevel;
        data["discountRate"] = this.discountRate;
        data["reOrderQuantity"] = this.reOrderQuantity;
        data["costPrice"] = this.costPrice;
        data["retailPrice"] = this.retailPrice;
        data["wholeSalePrice"] = this.wholeSalePrice;
        data["isActive"] = this.isActive;
        if (Array.isArray(this.supplierIds)) {
            data["supplierIds"] = [];
            for (let item of this.supplierIds)
                data["supplierIds"].push(item);
        }
        return data; 
    }

    clone(): CreateProductDto {
        const json = this.toJSON();
        let result = new CreateProductDto();
        result.init(json);
        return result;
    }
}

export interface ICreateProductDto {
    code: string;
    name: string;
    description: string | undefined;
    brandId: string | undefined;
    categoryId: string | undefined;
    barCode: string | undefined;
    packSize: number | undefined;
    reOrderLevel: number;
    discountRate: number | undefined;
    reOrderQuantity: number;
    costPrice: number;
    retailPrice: number;
    wholeSalePrice: number;
    isActive: boolean;
    supplierIds: string[] | undefined;
}

export class ProductDto implements IProductDto {
    code: string;
    name: string;
    description: string | undefined;
    brandId: string | undefined;
    categoryId: string | undefined;
    barCode: string | undefined;
    packSize: number | undefined;
    reOrderLevel: number;
    discountRate: number | undefined;
    reOrderQuantity: number;
    costPrice: number;
    retailPrice: number;
    wholeSalePrice: number;
    isActive: boolean;
    id: string;

    constructor(data?: IProductDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.brandId = _data["brandId"];
            this.categoryId = _data["categoryId"];
            this.barCode = _data["barCode"];
            this.packSize = _data["packSize"];
            this.reOrderLevel = _data["reOrderLevel"];
            this.discountRate = _data["discountRate"];
            this.reOrderQuantity = _data["reOrderQuantity"];
            this.costPrice = _data["costPrice"];
            this.retailPrice = _data["retailPrice"];
            this.wholeSalePrice = _data["wholeSalePrice"];
            this.isActive = _data["isActive"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ProductDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["name"] = this.name;
        data["description"] = this.description;
        data["brandId"] = this.brandId;
        data["categoryId"] = this.categoryId;
        data["barCode"] = this.barCode;
        data["packSize"] = this.packSize;
        data["reOrderLevel"] = this.reOrderLevel;
        data["discountRate"] = this.discountRate;
        data["reOrderQuantity"] = this.reOrderQuantity;
        data["costPrice"] = this.costPrice;
        data["retailPrice"] = this.retailPrice;
        data["wholeSalePrice"] = this.wholeSalePrice;
        data["isActive"] = this.isActive;
        data["id"] = this.id;
        return data; 
    }

    clone(): ProductDto {
        const json = this.toJSON();
        let result = new ProductDto();
        result.init(json);
        return result;
    }
}

export interface IProductDto {
    code: string;
    name: string;
    description: string | undefined;
    brandId: string | undefined;
    categoryId: string | undefined;
    barCode: string | undefined;
    packSize: number | undefined;
    reOrderLevel: number;
    discountRate: number | undefined;
    reOrderQuantity: number;
    costPrice: number;
    retailPrice: number;
    wholeSalePrice: number;
    isActive: boolean;
    id: string;
}

export class ProductDtoPagedResultDto implements IProductDtoPagedResultDto {
    totalCount: number;
    items: ProductDto[] | undefined;

    constructor(data?: IProductDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(ProductDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProductDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ProductDtoPagedResultDto {
        const json = this.toJSON();
        let result = new ProductDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IProductDtoPagedResultDto {
    totalCount: number;
    items: ProductDto[] | undefined;
}

export class UpdateProductDto implements IUpdateProductDto {
    code: string;
    name: string;
    description: string | undefined;
    brandId: string | undefined;
    categoryId: string | undefined;
    barCode: string | undefined;
    packSize: number | undefined;
    reOrderLevel: number;
    discountRate: number | undefined;
    reOrderQuantity: number;
    costPrice: number;
    retailPrice: number;
    wholeSalePrice: number;
    isActive: boolean;
    supplierIds: string[] | undefined;
    id: string;

    constructor(data?: IUpdateProductDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.brandId = _data["brandId"];
            this.categoryId = _data["categoryId"];
            this.barCode = _data["barCode"];
            this.packSize = _data["packSize"];
            this.reOrderLevel = _data["reOrderLevel"];
            this.discountRate = _data["discountRate"];
            this.reOrderQuantity = _data["reOrderQuantity"];
            this.costPrice = _data["costPrice"];
            this.retailPrice = _data["retailPrice"];
            this.wholeSalePrice = _data["wholeSalePrice"];
            this.isActive = _data["isActive"];
            if (Array.isArray(_data["supplierIds"])) {
                this.supplierIds = [] as any;
                for (let item of _data["supplierIds"])
                    this.supplierIds.push(item);
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateProductDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProductDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["name"] = this.name;
        data["description"] = this.description;
        data["brandId"] = this.brandId;
        data["categoryId"] = this.categoryId;
        data["barCode"] = this.barCode;
        data["packSize"] = this.packSize;
        data["reOrderLevel"] = this.reOrderLevel;
        data["discountRate"] = this.discountRate;
        data["reOrderQuantity"] = this.reOrderQuantity;
        data["costPrice"] = this.costPrice;
        data["retailPrice"] = this.retailPrice;
        data["wholeSalePrice"] = this.wholeSalePrice;
        data["isActive"] = this.isActive;
        if (Array.isArray(this.supplierIds)) {
            data["supplierIds"] = [];
            for (let item of this.supplierIds)
                data["supplierIds"].push(item);
        }
        data["id"] = this.id;
        return data; 
    }

    clone(): UpdateProductDto {
        const json = this.toJSON();
        let result = new UpdateProductDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateProductDto {
    code: string;
    name: string;
    description: string | undefined;
    brandId: string | undefined;
    categoryId: string | undefined;
    barCode: string | undefined;
    packSize: number | undefined;
    reOrderLevel: number;
    discountRate: number | undefined;
    reOrderQuantity: number;
    costPrice: number;
    retailPrice: number;
    wholeSalePrice: number;
    isActive: boolean;
    supplierIds: string[] | undefined;
    id: string;
}

export enum ProductSearchType {
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export class ProductSearchResultDto implements IProductSearchResultDto {
    id: string;
    barCode: string | undefined;
    code: string | undefined;
    name: string | undefined;
    isActive: boolean;

    constructor(data?: IProductSearchResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.barCode = _data["barCode"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): ProductSearchResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductSearchResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["barCode"] = this.barCode;
        data["code"] = this.code;
        data["name"] = this.name;
        data["isActive"] = this.isActive;
        return data; 
    }

    clone(): ProductSearchResultDto {
        const json = this.toJSON();
        let result = new ProductSearchResultDto();
        result.init(json);
        return result;
    }
}

export interface IProductSearchResultDto {
    id: string;
    barCode: string | undefined;
    code: string | undefined;
    name: string | undefined;
    isActive: boolean;
}

export class CreateWarehouseDto implements ICreateWarehouseDto {
    code: string;
    name: string;
    description: string | undefined;
    contactPersonName: string | undefined;
    contactNumber: string | undefined;
    isActive: boolean;
    isDefault: boolean;

    constructor(data?: ICreateWarehouseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.contactPersonName = _data["contactPersonName"];
            this.contactNumber = _data["contactNumber"];
            this.isActive = _data["isActive"];
            this.isDefault = _data["isDefault"];
        }
    }

    static fromJS(data: any): CreateWarehouseDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateWarehouseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["name"] = this.name;
        data["description"] = this.description;
        data["contactPersonName"] = this.contactPersonName;
        data["contactNumber"] = this.contactNumber;
        data["isActive"] = this.isActive;
        data["isDefault"] = this.isDefault;
        return data; 
    }

    clone(): CreateWarehouseDto {
        const json = this.toJSON();
        let result = new CreateWarehouseDto();
        result.init(json);
        return result;
    }
}

export interface ICreateWarehouseDto {
    code: string;
    name: string;
    description: string | undefined;
    contactPersonName: string | undefined;
    contactNumber: string | undefined;
    isActive: boolean;
    isDefault: boolean;
}

export class WarehouseDto implements IWarehouseDto {
    code: string;
    name: string;
    description: string | undefined;
    contactPersonName: string | undefined;
    contactNumber: string | undefined;
    isActive: boolean;
    isDefault: boolean;
    id: string;

    constructor(data?: IWarehouseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.contactPersonName = _data["contactPersonName"];
            this.contactNumber = _data["contactNumber"];
            this.isActive = _data["isActive"];
            this.isDefault = _data["isDefault"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): WarehouseDto {
        data = typeof data === 'object' ? data : {};
        let result = new WarehouseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["name"] = this.name;
        data["description"] = this.description;
        data["contactPersonName"] = this.contactPersonName;
        data["contactNumber"] = this.contactNumber;
        data["isActive"] = this.isActive;
        data["isDefault"] = this.isDefault;
        data["id"] = this.id;
        return data; 
    }

    clone(): WarehouseDto {
        const json = this.toJSON();
        let result = new WarehouseDto();
        result.init(json);
        return result;
    }
}

export interface IWarehouseDto {
    code: string;
    name: string;
    description: string | undefined;
    contactPersonName: string | undefined;
    contactNumber: string | undefined;
    isActive: boolean;
    isDefault: boolean;
    id: string;
}

export class WarehouseDtoPagedResultDto implements IWarehouseDtoPagedResultDto {
    totalCount: number;
    items: WarehouseDto[] | undefined;

    constructor(data?: IWarehouseDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(WarehouseDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WarehouseDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new WarehouseDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): WarehouseDtoPagedResultDto {
        const json = this.toJSON();
        let result = new WarehouseDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IWarehouseDtoPagedResultDto {
    totalCount: number;
    items: WarehouseDto[] | undefined;
}

export class UpdateWarehouseDto implements IUpdateWarehouseDto {
    code: string;
    name: string;
    description: string | undefined;
    contactPersonName: string | undefined;
    contactNumber: string | undefined;
    isActive: boolean;
    isDefault: boolean;
    id: string;

    constructor(data?: IUpdateWarehouseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.contactPersonName = _data["contactPersonName"];
            this.contactNumber = _data["contactNumber"];
            this.isActive = _data["isActive"];
            this.isDefault = _data["isDefault"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateWarehouseDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateWarehouseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["name"] = this.name;
        data["description"] = this.description;
        data["contactPersonName"] = this.contactPersonName;
        data["contactNumber"] = this.contactNumber;
        data["isActive"] = this.isActive;
        data["isDefault"] = this.isDefault;
        data["id"] = this.id;
        return data; 
    }

    clone(): UpdateWarehouseDto {
        const json = this.toJSON();
        let result = new UpdateWarehouseDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateWarehouseDto {
    code: string;
    name: string;
    description: string | undefined;
    contactPersonName: string | undefined;
    contactNumber: string | undefined;
    isActive: boolean;
    isDefault: boolean;
    id: string;
}

export class CreateCategoryDto implements ICreateCategoryDto {
    name: string;
    isActive: boolean;

    constructor(data?: ICreateCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): CreateCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["isActive"] = this.isActive;
        return data; 
    }

    clone(): CreateCategoryDto {
        const json = this.toJSON();
        let result = new CreateCategoryDto();
        result.init(json);
        return result;
    }
}

export interface ICreateCategoryDto {
    name: string;
    isActive: boolean;
}

export class CategoryDto implements ICategoryDto {
    name: string;
    isActive: boolean;
    id: string;

    constructor(data?: ICategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.isActive = _data["isActive"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["isActive"] = this.isActive;
        data["id"] = this.id;
        return data; 
    }

    clone(): CategoryDto {
        const json = this.toJSON();
        let result = new CategoryDto();
        result.init(json);
        return result;
    }
}

export interface ICategoryDto {
    name: string;
    isActive: boolean;
    id: string;
}

export class CategoryDtoPagedResultDto implements ICategoryDtoPagedResultDto {
    totalCount: number;
    items: CategoryDto[] | undefined;

    constructor(data?: ICategoryDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(CategoryDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CategoryDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): CategoryDtoPagedResultDto {
        const json = this.toJSON();
        let result = new CategoryDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface ICategoryDtoPagedResultDto {
    totalCount: number;
    items: CategoryDto[] | undefined;
}

export class CreateBrandDto implements ICreateBrandDto {
    name: string;
    isActive: boolean;

    constructor(data?: ICreateBrandDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): CreateBrandDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateBrandDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["isActive"] = this.isActive;
        return data; 
    }

    clone(): CreateBrandDto {
        const json = this.toJSON();
        let result = new CreateBrandDto();
        result.init(json);
        return result;
    }
}

export interface ICreateBrandDto {
    name: string;
    isActive: boolean;
}

export class BrandDto implements IBrandDto {
    name: string;
    isActive: boolean;
    id: string;

    constructor(data?: IBrandDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.isActive = _data["isActive"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): BrandDto {
        data = typeof data === 'object' ? data : {};
        let result = new BrandDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["isActive"] = this.isActive;
        data["id"] = this.id;
        return data; 
    }

    clone(): BrandDto {
        const json = this.toJSON();
        let result = new BrandDto();
        result.init(json);
        return result;
    }
}

export interface IBrandDto {
    name: string;
    isActive: boolean;
    id: string;
}

export class BrandDtoPagedResultDto implements IBrandDtoPagedResultDto {
    totalCount: number;
    items: BrandDto[] | undefined;

    constructor(data?: IBrandDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(BrandDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BrandDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new BrandDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): BrandDtoPagedResultDto {
        const json = this.toJSON();
        let result = new BrandDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IBrandDtoPagedResultDto {
    totalCount: number;
    items: BrandDto[] | undefined;
}

export class ProductStockBalanceDto implements IProductStockBalanceDto {
    stockBalanceId: string;
    productId: string;
    warehouseId: string | undefined;
    warehouseCode: string | undefined;
    warehouseName: string | undefined;
    expiryDate: moment.Moment | undefined;
    batchNumber: string | undefined;
    allocatedQuantity: number;
    allocatedQuantityUnitOfMeasureUnit: string | undefined;
    bookBalanceQuantity: number;
    bookBalanceUnitOfMeasureUnit: string | undefined;
    costPrice: number;
    sellingPrice: number;
    maximumRetailPrice: number;
    isSelected: boolean;

    constructor(data?: IProductStockBalanceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.stockBalanceId = _data["stockBalanceId"];
            this.productId = _data["productId"];
            this.warehouseId = _data["warehouseId"];
            this.warehouseCode = _data["warehouseCode"];
            this.warehouseName = _data["warehouseName"];
            this.expiryDate = _data["expiryDate"] ? moment(_data["expiryDate"].toString()) : <any>undefined;
            this.batchNumber = _data["batchNumber"];
            this.allocatedQuantity = _data["allocatedQuantity"];
            this.allocatedQuantityUnitOfMeasureUnit = _data["allocatedQuantityUnitOfMeasureUnit"];
            this.bookBalanceQuantity = _data["bookBalanceQuantity"];
            this.bookBalanceUnitOfMeasureUnit = _data["bookBalanceUnitOfMeasureUnit"];
            this.costPrice = _data["costPrice"];
            this.sellingPrice = _data["sellingPrice"];
            this.maximumRetailPrice = _data["maximumRetailPrice"];
            this.isSelected = _data["isSelected"];
        }
    }

    static fromJS(data: any): ProductStockBalanceDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductStockBalanceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["stockBalanceId"] = this.stockBalanceId;
        data["productId"] = this.productId;
        data["warehouseId"] = this.warehouseId;
        data["warehouseCode"] = this.warehouseCode;
        data["warehouseName"] = this.warehouseName;
        data["expiryDate"] = this.expiryDate ? this.expiryDate.toISOString() : <any>undefined;
        data["batchNumber"] = this.batchNumber;
        data["allocatedQuantity"] = this.allocatedQuantity;
        data["allocatedQuantityUnitOfMeasureUnit"] = this.allocatedQuantityUnitOfMeasureUnit;
        data["bookBalanceQuantity"] = this.bookBalanceQuantity;
        data["bookBalanceUnitOfMeasureUnit"] = this.bookBalanceUnitOfMeasureUnit;
        data["costPrice"] = this.costPrice;
        data["sellingPrice"] = this.sellingPrice;
        data["maximumRetailPrice"] = this.maximumRetailPrice;
        data["isSelected"] = this.isSelected;
        return data; 
    }

    clone(): ProductStockBalanceDto {
        const json = this.toJSON();
        let result = new ProductStockBalanceDto();
        result.init(json);
        return result;
    }
}

export interface IProductStockBalanceDto {
    stockBalanceId: string;
    productId: string;
    warehouseId: string | undefined;
    warehouseCode: string | undefined;
    warehouseName: string | undefined;
    expiryDate: moment.Moment | undefined;
    batchNumber: string | undefined;
    allocatedQuantity: number;
    allocatedQuantityUnitOfMeasureUnit: string | undefined;
    bookBalanceQuantity: number;
    bookBalanceUnitOfMeasureUnit: string | undefined;
    costPrice: number;
    sellingPrice: number;
    maximumRetailPrice: number;
    isSelected: boolean;
}

export class ProductStockBalanceDtoResponseDto implements IProductStockBalanceDtoResponseDto {
    statusCode: number;
    message: string | undefined;
    items: ProductStockBalanceDto[] | undefined;

    constructor(data?: IProductStockBalanceDtoResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.statusCode = _data["statusCode"];
            this.message = _data["message"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(ProductStockBalanceDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProductStockBalanceDtoResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductStockBalanceDtoResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["statusCode"] = this.statusCode;
        data["message"] = this.message;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ProductStockBalanceDtoResponseDto {
        const json = this.toJSON();
        let result = new ProductStockBalanceDtoResponseDto();
        result.init(json);
        return result;
    }
}

export interface IProductStockBalanceDtoResponseDto {
    statusCode: number;
    message: string | undefined;
    items: ProductStockBalanceDto[] | undefined;
}

export class CreateSupplierDto implements ICreateSupplierDto {
    code: string;
    businessName: string;
    personTitleId: string | undefined;
    firstName: string;
    middleName: string | undefined;
    lastName: string | undefined;
    contactNumber1: string;
    contactNumber2: string | undefined;
    contactNumber3: string | undefined;
    email: string | undefined;
    noOfInvoices: number | undefined;
    creditLimit: number | undefined;
    creditPeriod: number | undefined;
    discountRate: number | undefined;
    classificationId: string | undefined;
    priceGroupId: string | undefined;
    isActive: boolean;

    constructor(data?: ICreateSupplierDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.businessName = _data["businessName"];
            this.personTitleId = _data["personTitleId"];
            this.firstName = _data["firstName"];
            this.middleName = _data["middleName"];
            this.lastName = _data["lastName"];
            this.contactNumber1 = _data["contactNumber1"];
            this.contactNumber2 = _data["contactNumber2"];
            this.contactNumber3 = _data["contactNumber3"];
            this.email = _data["email"];
            this.noOfInvoices = _data["noOfInvoices"];
            this.creditLimit = _data["creditLimit"];
            this.creditPeriod = _data["creditPeriod"];
            this.discountRate = _data["discountRate"];
            this.classificationId = _data["classificationId"];
            this.priceGroupId = _data["priceGroupId"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): CreateSupplierDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateSupplierDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["businessName"] = this.businessName;
        data["personTitleId"] = this.personTitleId;
        data["firstName"] = this.firstName;
        data["middleName"] = this.middleName;
        data["lastName"] = this.lastName;
        data["contactNumber1"] = this.contactNumber1;
        data["contactNumber2"] = this.contactNumber2;
        data["contactNumber3"] = this.contactNumber3;
        data["email"] = this.email;
        data["noOfInvoices"] = this.noOfInvoices;
        data["creditLimit"] = this.creditLimit;
        data["creditPeriod"] = this.creditPeriod;
        data["discountRate"] = this.discountRate;
        data["classificationId"] = this.classificationId;
        data["priceGroupId"] = this.priceGroupId;
        data["isActive"] = this.isActive;
        return data; 
    }

    clone(): CreateSupplierDto {
        const json = this.toJSON();
        let result = new CreateSupplierDto();
        result.init(json);
        return result;
    }
}

export interface ICreateSupplierDto {
    code: string;
    businessName: string;
    personTitleId: string | undefined;
    firstName: string;
    middleName: string | undefined;
    lastName: string | undefined;
    contactNumber1: string;
    contactNumber2: string | undefined;
    contactNumber3: string | undefined;
    email: string | undefined;
    noOfInvoices: number | undefined;
    creditLimit: number | undefined;
    creditPeriod: number | undefined;
    discountRate: number | undefined;
    classificationId: string | undefined;
    priceGroupId: string | undefined;
    isActive: boolean;
}

export class SupplierDto implements ISupplierDto {
    code: string;
    businessName: string;
    personTitleId: string | undefined;
    firstName: string;
    middleName: string | undefined;
    lastName: string | undefined;
    contactNumber1: string;
    contactNumber2: string | undefined;
    contactNumber3: string | undefined;
    email: string | undefined;
    noOfInvoices: number | undefined;
    creditLimit: number | undefined;
    creditPeriod: number | undefined;
    discountRate: number | undefined;
    classificationId: string | undefined;
    priceGroupId: string | undefined;
    isActive: boolean;
    id: string;

    constructor(data?: ISupplierDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.businessName = _data["businessName"];
            this.personTitleId = _data["personTitleId"];
            this.firstName = _data["firstName"];
            this.middleName = _data["middleName"];
            this.lastName = _data["lastName"];
            this.contactNumber1 = _data["contactNumber1"];
            this.contactNumber2 = _data["contactNumber2"];
            this.contactNumber3 = _data["contactNumber3"];
            this.email = _data["email"];
            this.noOfInvoices = _data["noOfInvoices"];
            this.creditLimit = _data["creditLimit"];
            this.creditPeriod = _data["creditPeriod"];
            this.discountRate = _data["discountRate"];
            this.classificationId = _data["classificationId"];
            this.priceGroupId = _data["priceGroupId"];
            this.isActive = _data["isActive"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SupplierDto {
        data = typeof data === 'object' ? data : {};
        let result = new SupplierDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["businessName"] = this.businessName;
        data["personTitleId"] = this.personTitleId;
        data["firstName"] = this.firstName;
        data["middleName"] = this.middleName;
        data["lastName"] = this.lastName;
        data["contactNumber1"] = this.contactNumber1;
        data["contactNumber2"] = this.contactNumber2;
        data["contactNumber3"] = this.contactNumber3;
        data["email"] = this.email;
        data["noOfInvoices"] = this.noOfInvoices;
        data["creditLimit"] = this.creditLimit;
        data["creditPeriod"] = this.creditPeriod;
        data["discountRate"] = this.discountRate;
        data["classificationId"] = this.classificationId;
        data["priceGroupId"] = this.priceGroupId;
        data["isActive"] = this.isActive;
        data["id"] = this.id;
        return data; 
    }

    clone(): SupplierDto {
        const json = this.toJSON();
        let result = new SupplierDto();
        result.init(json);
        return result;
    }
}

export interface ISupplierDto {
    code: string;
    businessName: string;
    personTitleId: string | undefined;
    firstName: string;
    middleName: string | undefined;
    lastName: string | undefined;
    contactNumber1: string;
    contactNumber2: string | undefined;
    contactNumber3: string | undefined;
    email: string | undefined;
    noOfInvoices: number | undefined;
    creditLimit: number | undefined;
    creditPeriod: number | undefined;
    discountRate: number | undefined;
    classificationId: string | undefined;
    priceGroupId: string | undefined;
    isActive: boolean;
    id: string;
}

export class SupplierDtoPagedResultDto implements ISupplierDtoPagedResultDto {
    totalCount: number;
    items: SupplierDto[] | undefined;

    constructor(data?: ISupplierDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(SupplierDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SupplierDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new SupplierDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): SupplierDtoPagedResultDto {
        const json = this.toJSON();
        let result = new SupplierDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface ISupplierDtoPagedResultDto {
    totalCount: number;
    items: SupplierDto[] | undefined;
}

export enum PurchaseOrderStatus {
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export class CreatePurchaseOrderProductDto implements ICreatePurchaseOrderProductDto {
    sequenceNo: number;
    productId: string;
    productCode: string;
    productName: string | undefined;
    warehouseId: string;
    warehouseCode: string | undefined;
    warehouseName: string | undefined;
    costPrice: number;
    orderQuantity: number;
    freeQuantity: number;
    discountRate: number;
    discountAmount: number;
    lineTotal: number;
    remarks: string | undefined;

    constructor(data?: ICreatePurchaseOrderProductDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sequenceNo = _data["sequenceNo"];
            this.productId = _data["productId"];
            this.productCode = _data["productCode"];
            this.productName = _data["productName"];
            this.warehouseId = _data["warehouseId"];
            this.warehouseCode = _data["warehouseCode"];
            this.warehouseName = _data["warehouseName"];
            this.costPrice = _data["costPrice"];
            this.orderQuantity = _data["orderQuantity"];
            this.freeQuantity = _data["freeQuantity"];
            this.discountRate = _data["discountRate"];
            this.discountAmount = _data["discountAmount"];
            this.lineTotal = _data["lineTotal"];
            this.remarks = _data["remarks"];
        }
    }

    static fromJS(data: any): CreatePurchaseOrderProductDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePurchaseOrderProductDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sequenceNo"] = this.sequenceNo;
        data["productId"] = this.productId;
        data["productCode"] = this.productCode;
        data["productName"] = this.productName;
        data["warehouseId"] = this.warehouseId;
        data["warehouseCode"] = this.warehouseCode;
        data["warehouseName"] = this.warehouseName;
        data["costPrice"] = this.costPrice;
        data["orderQuantity"] = this.orderQuantity;
        data["freeQuantity"] = this.freeQuantity;
        data["discountRate"] = this.discountRate;
        data["discountAmount"] = this.discountAmount;
        data["lineTotal"] = this.lineTotal;
        data["remarks"] = this.remarks;
        return data; 
    }

    clone(): CreatePurchaseOrderProductDto {
        const json = this.toJSON();
        let result = new CreatePurchaseOrderProductDto();
        result.init(json);
        return result;
    }
}

export interface ICreatePurchaseOrderProductDto {
    sequenceNo: number;
    productId: string;
    productCode: string;
    productName: string | undefined;
    warehouseId: string;
    warehouseCode: string | undefined;
    warehouseName: string | undefined;
    costPrice: number;
    orderQuantity: number;
    freeQuantity: number;
    discountRate: number;
    discountAmount: number;
    lineTotal: number;
    remarks: string | undefined;
}

export class CreatePurchaseOrderDto implements ICreatePurchaseOrderDto {
    purchaseOrderNumber: string;
    referenceNumber: string | undefined;
    expectedDeliveryDate: moment.Moment | undefined;
    supplierId: string;
    supplierCode: string;
    supplierName: string;
    taxRate: number;
    taxAmount: number;
    discountRate: number;
    discountAmount: number;
    grossAmount: number;
    netAmount: number;
    status: PurchaseOrderStatus;
    remarks: string | undefined;
    purchaseOrderProducts: CreatePurchaseOrderProductDto[] | undefined;

    constructor(data?: ICreatePurchaseOrderDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.purchaseOrderNumber = _data["purchaseOrderNumber"];
            this.referenceNumber = _data["referenceNumber"];
            this.expectedDeliveryDate = _data["expectedDeliveryDate"] ? moment(_data["expectedDeliveryDate"].toString()) : <any>undefined;
            this.supplierId = _data["supplierId"];
            this.supplierCode = _data["supplierCode"];
            this.supplierName = _data["supplierName"];
            this.taxRate = _data["taxRate"];
            this.taxAmount = _data["taxAmount"];
            this.discountRate = _data["discountRate"];
            this.discountAmount = _data["discountAmount"];
            this.grossAmount = _data["grossAmount"];
            this.netAmount = _data["netAmount"];
            this.status = _data["status"];
            this.remarks = _data["remarks"];
            if (Array.isArray(_data["purchaseOrderProducts"])) {
                this.purchaseOrderProducts = [] as any;
                for (let item of _data["purchaseOrderProducts"])
                    this.purchaseOrderProducts.push(CreatePurchaseOrderProductDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreatePurchaseOrderDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePurchaseOrderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["purchaseOrderNumber"] = this.purchaseOrderNumber;
        data["referenceNumber"] = this.referenceNumber;
        data["expectedDeliveryDate"] = this.expectedDeliveryDate ? this.expectedDeliveryDate.toISOString() : <any>undefined;
        data["supplierId"] = this.supplierId;
        data["supplierCode"] = this.supplierCode;
        data["supplierName"] = this.supplierName;
        data["taxRate"] = this.taxRate;
        data["taxAmount"] = this.taxAmount;
        data["discountRate"] = this.discountRate;
        data["discountAmount"] = this.discountAmount;
        data["grossAmount"] = this.grossAmount;
        data["netAmount"] = this.netAmount;
        data["status"] = this.status;
        data["remarks"] = this.remarks;
        if (Array.isArray(this.purchaseOrderProducts)) {
            data["purchaseOrderProducts"] = [];
            for (let item of this.purchaseOrderProducts)
                data["purchaseOrderProducts"].push(item.toJSON());
        }
        return data; 
    }

    clone(): CreatePurchaseOrderDto {
        const json = this.toJSON();
        let result = new CreatePurchaseOrderDto();
        result.init(json);
        return result;
    }
}

export interface ICreatePurchaseOrderDto {
    purchaseOrderNumber: string;
    referenceNumber: string | undefined;
    expectedDeliveryDate: moment.Moment | undefined;
    supplierId: string;
    supplierCode: string;
    supplierName: string;
    taxRate: number;
    taxAmount: number;
    discountRate: number;
    discountAmount: number;
    grossAmount: number;
    netAmount: number;
    status: PurchaseOrderStatus;
    remarks: string | undefined;
    purchaseOrderProducts: CreatePurchaseOrderProductDto[] | undefined;
}

export class PurchaseOrderDto implements IPurchaseOrderDto {
    purchaseOrderNumber: string;
    referenceNumber: string | undefined;
    expectedDeliveryDate: moment.Moment | undefined;
    supplierId: string;
    supplierCode: string;
    supplierName: string;
    taxRate: number;
    taxAmount: number;
    discountRate: number;
    discountAmount: number;
    grossAmount: number;
    netAmount: number;
    status: PurchaseOrderStatus;
    remarks: string | undefined;
    id: string;

    constructor(data?: IPurchaseOrderDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.purchaseOrderNumber = _data["purchaseOrderNumber"];
            this.referenceNumber = _data["referenceNumber"];
            this.expectedDeliveryDate = _data["expectedDeliveryDate"] ? moment(_data["expectedDeliveryDate"].toString()) : <any>undefined;
            this.supplierId = _data["supplierId"];
            this.supplierCode = _data["supplierCode"];
            this.supplierName = _data["supplierName"];
            this.taxRate = _data["taxRate"];
            this.taxAmount = _data["taxAmount"];
            this.discountRate = _data["discountRate"];
            this.discountAmount = _data["discountAmount"];
            this.grossAmount = _data["grossAmount"];
            this.netAmount = _data["netAmount"];
            this.status = _data["status"];
            this.remarks = _data["remarks"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): PurchaseOrderDto {
        data = typeof data === 'object' ? data : {};
        let result = new PurchaseOrderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["purchaseOrderNumber"] = this.purchaseOrderNumber;
        data["referenceNumber"] = this.referenceNumber;
        data["expectedDeliveryDate"] = this.expectedDeliveryDate ? this.expectedDeliveryDate.toISOString() : <any>undefined;
        data["supplierId"] = this.supplierId;
        data["supplierCode"] = this.supplierCode;
        data["supplierName"] = this.supplierName;
        data["taxRate"] = this.taxRate;
        data["taxAmount"] = this.taxAmount;
        data["discountRate"] = this.discountRate;
        data["discountAmount"] = this.discountAmount;
        data["grossAmount"] = this.grossAmount;
        data["netAmount"] = this.netAmount;
        data["status"] = this.status;
        data["remarks"] = this.remarks;
        data["id"] = this.id;
        return data; 
    }

    clone(): PurchaseOrderDto {
        const json = this.toJSON();
        let result = new PurchaseOrderDto();
        result.init(json);
        return result;
    }
}

export interface IPurchaseOrderDto {
    purchaseOrderNumber: string;
    referenceNumber: string | undefined;
    expectedDeliveryDate: moment.Moment | undefined;
    supplierId: string;
    supplierCode: string;
    supplierName: string;
    taxRate: number;
    taxAmount: number;
    discountRate: number;
    discountAmount: number;
    grossAmount: number;
    netAmount: number;
    status: PurchaseOrderStatus;
    remarks: string | undefined;
    id: string;
}

export class CreateRoleDto implements ICreateRoleDto {
    name: string;
    displayName: string;
    normalizedName: string | undefined;
    description: string | undefined;
    grantedPermissions: string[] | undefined;

    constructor(data?: ICreateRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.normalizedName = _data["normalizedName"];
            this.description = _data["description"];
            if (Array.isArray(_data["grantedPermissions"])) {
                this.grantedPermissions = [] as any;
                for (let item of _data["grantedPermissions"])
                    this.grantedPermissions.push(item);
            }
        }
    }

    static fromJS(data: any): CreateRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["normalizedName"] = this.normalizedName;
        data["description"] = this.description;
        if (Array.isArray(this.grantedPermissions)) {
            data["grantedPermissions"] = [];
            for (let item of this.grantedPermissions)
                data["grantedPermissions"].push(item);
        }
        return data; 
    }

    clone(): CreateRoleDto {
        const json = this.toJSON();
        let result = new CreateRoleDto();
        result.init(json);
        return result;
    }
}

export interface ICreateRoleDto {
    name: string;
    displayName: string;
    normalizedName: string | undefined;
    description: string | undefined;
    grantedPermissions: string[] | undefined;
}

export class RoleDto implements IRoleDto {
    name: string;
    displayName: string;
    normalizedName: string | undefined;
    description: string | undefined;
    grantedPermissions: string[] | undefined;
    id: number;

    constructor(data?: IRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.normalizedName = _data["normalizedName"];
            this.description = _data["description"];
            if (Array.isArray(_data["grantedPermissions"])) {
                this.grantedPermissions = [] as any;
                for (let item of _data["grantedPermissions"])
                    this.grantedPermissions.push(item);
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): RoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["normalizedName"] = this.normalizedName;
        data["description"] = this.description;
        if (Array.isArray(this.grantedPermissions)) {
            data["grantedPermissions"] = [];
            for (let item of this.grantedPermissions)
                data["grantedPermissions"].push(item);
        }
        data["id"] = this.id;
        return data; 
    }

    clone(): RoleDto {
        const json = this.toJSON();
        let result = new RoleDto();
        result.init(json);
        return result;
    }
}

export interface IRoleDto {
    name: string;
    displayName: string;
    normalizedName: string | undefined;
    description: string | undefined;
    grantedPermissions: string[] | undefined;
    id: number;
}

export class RoleListDto implements IRoleListDto {
    name: string | undefined;
    displayName: string | undefined;
    isStatic: boolean;
    isDefault: boolean;
    creationTime: moment.Moment;
    id: number;

    constructor(data?: IRoleListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.isStatic = _data["isStatic"];
            this.isDefault = _data["isDefault"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): RoleListDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["isStatic"] = this.isStatic;
        data["isDefault"] = this.isDefault;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): RoleListDto {
        const json = this.toJSON();
        let result = new RoleListDto();
        result.init(json);
        return result;
    }
}

export interface IRoleListDto {
    name: string | undefined;
    displayName: string | undefined;
    isStatic: boolean;
    isDefault: boolean;
    creationTime: moment.Moment;
    id: number;
}

export class RoleListDtoListResultDto implements IRoleListDtoListResultDto {
    items: RoleListDto[] | undefined;

    constructor(data?: IRoleListDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(RoleListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RoleListDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleListDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): RoleListDtoListResultDto {
        const json = this.toJSON();
        let result = new RoleListDtoListResultDto();
        result.init(json);
        return result;
    }
}

export interface IRoleListDtoListResultDto {
    items: RoleListDto[] | undefined;
}

export class PermissionDto implements IPermissionDto {
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    id: number;

    constructor(data?: IPermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): PermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["id"] = this.id;
        return data; 
    }

    clone(): PermissionDto {
        const json = this.toJSON();
        let result = new PermissionDto();
        result.init(json);
        return result;
    }
}

export interface IPermissionDto {
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    id: number;
}

export class PermissionDtoListResultDto implements IPermissionDtoListResultDto {
    items: PermissionDto[] | undefined;

    constructor(data?: IPermissionDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(PermissionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PermissionDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PermissionDtoListResultDto {
        const json = this.toJSON();
        let result = new PermissionDtoListResultDto();
        result.init(json);
        return result;
    }
}

export interface IPermissionDtoListResultDto {
    items: PermissionDto[] | undefined;
}

export class RoleEditDto implements IRoleEditDto {
    name: string;
    displayName: string;
    description: string | undefined;
    isStatic: boolean;
    id: number;

    constructor(data?: IRoleEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
            this.isStatic = _data["isStatic"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): RoleEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["isStatic"] = this.isStatic;
        data["id"] = this.id;
        return data; 
    }

    clone(): RoleEditDto {
        const json = this.toJSON();
        let result = new RoleEditDto();
        result.init(json);
        return result;
    }
}

export interface IRoleEditDto {
    name: string;
    displayName: string;
    description: string | undefined;
    isStatic: boolean;
    id: number;
}

export class FlatPermissionDto implements IFlatPermissionDto {
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;

    constructor(data?: IFlatPermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): FlatPermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new FlatPermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        return data; 
    }

    clone(): FlatPermissionDto {
        const json = this.toJSON();
        let result = new FlatPermissionDto();
        result.init(json);
        return result;
    }
}

export interface IFlatPermissionDto {
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
}

export class GetRoleForEditOutput implements IGetRoleForEditOutput {
    role: RoleEditDto;
    permissions: FlatPermissionDto[] | undefined;
    grantedPermissionNames: string[] | undefined;

    constructor(data?: IGetRoleForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.role = _data["role"] ? RoleEditDto.fromJS(_data["role"]) : <any>undefined;
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions.push(FlatPermissionDto.fromJS(item));
            }
            if (Array.isArray(_data["grantedPermissionNames"])) {
                this.grantedPermissionNames = [] as any;
                for (let item of _data["grantedPermissionNames"])
                    this.grantedPermissionNames.push(item);
            }
        }
    }

    static fromJS(data: any): GetRoleForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetRoleForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["role"] = this.role ? this.role.toJSON() : <any>undefined;
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        if (Array.isArray(this.grantedPermissionNames)) {
            data["grantedPermissionNames"] = [];
            for (let item of this.grantedPermissionNames)
                data["grantedPermissionNames"].push(item);
        }
        return data; 
    }

    clone(): GetRoleForEditOutput {
        const json = this.toJSON();
        let result = new GetRoleForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetRoleForEditOutput {
    role: RoleEditDto;
    permissions: FlatPermissionDto[] | undefined;
    grantedPermissionNames: string[] | undefined;
}

export class RoleDtoPagedResultDto implements IRoleDtoPagedResultDto {
    totalCount: number;
    items: RoleDto[] | undefined;

    constructor(data?: IRoleDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(RoleDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RoleDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): RoleDtoPagedResultDto {
        const json = this.toJSON();
        let result = new RoleDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IRoleDtoPagedResultDto {
    totalCount: number;
    items: RoleDto[] | undefined;
}

export class CreateCustomerDto implements ICreateCustomerDto {
    code: string;
    personTitleId: string | undefined;
    firstName: string;
    middleName: string | undefined;
    lastName: string | undefined;
    contactNumber1: string;
    contactNumber2: string | undefined;
    contactNumber3: string | undefined;
    email: string | undefined;
    noOfInvoices: number | undefined;
    creditLimit: number | undefined;
    creditPeriod: number | undefined;
    discountRate: number | undefined;
    classificationId: string | undefined;
    priceGroupId: string | undefined;
    isActive: boolean;

    constructor(data?: ICreateCustomerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.personTitleId = _data["personTitleId"];
            this.firstName = _data["firstName"];
            this.middleName = _data["middleName"];
            this.lastName = _data["lastName"];
            this.contactNumber1 = _data["contactNumber1"];
            this.contactNumber2 = _data["contactNumber2"];
            this.contactNumber3 = _data["contactNumber3"];
            this.email = _data["email"];
            this.noOfInvoices = _data["noOfInvoices"];
            this.creditLimit = _data["creditLimit"];
            this.creditPeriod = _data["creditPeriod"];
            this.discountRate = _data["discountRate"];
            this.classificationId = _data["classificationId"];
            this.priceGroupId = _data["priceGroupId"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): CreateCustomerDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCustomerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["personTitleId"] = this.personTitleId;
        data["firstName"] = this.firstName;
        data["middleName"] = this.middleName;
        data["lastName"] = this.lastName;
        data["contactNumber1"] = this.contactNumber1;
        data["contactNumber2"] = this.contactNumber2;
        data["contactNumber3"] = this.contactNumber3;
        data["email"] = this.email;
        data["noOfInvoices"] = this.noOfInvoices;
        data["creditLimit"] = this.creditLimit;
        data["creditPeriod"] = this.creditPeriod;
        data["discountRate"] = this.discountRate;
        data["classificationId"] = this.classificationId;
        data["priceGroupId"] = this.priceGroupId;
        data["isActive"] = this.isActive;
        return data; 
    }

    clone(): CreateCustomerDto {
        const json = this.toJSON();
        let result = new CreateCustomerDto();
        result.init(json);
        return result;
    }
}

export interface ICreateCustomerDto {
    code: string;
    personTitleId: string | undefined;
    firstName: string;
    middleName: string | undefined;
    lastName: string | undefined;
    contactNumber1: string;
    contactNumber2: string | undefined;
    contactNumber3: string | undefined;
    email: string | undefined;
    noOfInvoices: number | undefined;
    creditLimit: number | undefined;
    creditPeriod: number | undefined;
    discountRate: number | undefined;
    classificationId: string | undefined;
    priceGroupId: string | undefined;
    isActive: boolean;
}

export class CustomerDto implements ICustomerDto {
    code: string;
    personTitleId: string | undefined;
    firstName: string;
    middleName: string | undefined;
    lastName: string | undefined;
    contactNumber1: string;
    contactNumber2: string | undefined;
    contactNumber3: string | undefined;
    email: string | undefined;
    noOfInvoices: number | undefined;
    creditLimit: number | undefined;
    creditPeriod: number | undefined;
    discountRate: number | undefined;
    classificationId: string | undefined;
    priceGroupId: string | undefined;
    isActive: boolean;
    id: string;

    constructor(data?: ICustomerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.personTitleId = _data["personTitleId"];
            this.firstName = _data["firstName"];
            this.middleName = _data["middleName"];
            this.lastName = _data["lastName"];
            this.contactNumber1 = _data["contactNumber1"];
            this.contactNumber2 = _data["contactNumber2"];
            this.contactNumber3 = _data["contactNumber3"];
            this.email = _data["email"];
            this.noOfInvoices = _data["noOfInvoices"];
            this.creditLimit = _data["creditLimit"];
            this.creditPeriod = _data["creditPeriod"];
            this.discountRate = _data["discountRate"];
            this.classificationId = _data["classificationId"];
            this.priceGroupId = _data["priceGroupId"];
            this.isActive = _data["isActive"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CustomerDto {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["personTitleId"] = this.personTitleId;
        data["firstName"] = this.firstName;
        data["middleName"] = this.middleName;
        data["lastName"] = this.lastName;
        data["contactNumber1"] = this.contactNumber1;
        data["contactNumber2"] = this.contactNumber2;
        data["contactNumber3"] = this.contactNumber3;
        data["email"] = this.email;
        data["noOfInvoices"] = this.noOfInvoices;
        data["creditLimit"] = this.creditLimit;
        data["creditPeriod"] = this.creditPeriod;
        data["discountRate"] = this.discountRate;
        data["classificationId"] = this.classificationId;
        data["priceGroupId"] = this.priceGroupId;
        data["isActive"] = this.isActive;
        data["id"] = this.id;
        return data; 
    }

    clone(): CustomerDto {
        const json = this.toJSON();
        let result = new CustomerDto();
        result.init(json);
        return result;
    }
}

export interface ICustomerDto {
    code: string;
    personTitleId: string | undefined;
    firstName: string;
    middleName: string | undefined;
    lastName: string | undefined;
    contactNumber1: string;
    contactNumber2: string | undefined;
    contactNumber3: string | undefined;
    email: string | undefined;
    noOfInvoices: number | undefined;
    creditLimit: number | undefined;
    creditPeriod: number | undefined;
    discountRate: number | undefined;
    classificationId: string | undefined;
    priceGroupId: string | undefined;
    isActive: boolean;
    id: string;
}

export class CustomerDtoPagedResultDto implements ICustomerDtoPagedResultDto {
    totalCount: number;
    items: CustomerDto[] | undefined;

    constructor(data?: ICustomerDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(CustomerDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CustomerDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): CustomerDtoPagedResultDto {
        const json = this.toJSON();
        let result = new CustomerDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface ICustomerDtoPagedResultDto {
    totalCount: number;
    items: CustomerDto[] | undefined;
}

export class CreateTempSalesProductDto implements ICreateTempSalesProductDto {
    productId: string;
    barCode: string | undefined;
    code: string;
    name: string;
    stockBalanceId: string;
    expiryDate: moment.Moment | undefined;
    batchNumber: string | undefined;
    warehouseId: string | undefined;
    warehouseCode: string | undefined;
    warehouseName: string | undefined;
    bookBalanceQuantity: number;
    bookBalanceUnitOfMeasureUnit: string | undefined;
    costPrice: number;
    sellingPrice: number;
    maximumRetailPrice: number;
    isSelected: boolean;
    discountRate: number;
    discountAmount: number;
    quantity: number;
    lineTotal: number;
    isActive: boolean;

    constructor(data?: ICreateTempSalesProductDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productId = _data["productId"];
            this.barCode = _data["barCode"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.stockBalanceId = _data["stockBalanceId"];
            this.expiryDate = _data["expiryDate"] ? moment(_data["expiryDate"].toString()) : <any>undefined;
            this.batchNumber = _data["batchNumber"];
            this.warehouseId = _data["warehouseId"];
            this.warehouseCode = _data["warehouseCode"];
            this.warehouseName = _data["warehouseName"];
            this.bookBalanceQuantity = _data["bookBalanceQuantity"];
            this.bookBalanceUnitOfMeasureUnit = _data["bookBalanceUnitOfMeasureUnit"];
            this.costPrice = _data["costPrice"];
            this.sellingPrice = _data["sellingPrice"];
            this.maximumRetailPrice = _data["maximumRetailPrice"];
            this.isSelected = _data["isSelected"];
            this.discountRate = _data["discountRate"];
            this.discountAmount = _data["discountAmount"];
            this.quantity = _data["quantity"];
            this.lineTotal = _data["lineTotal"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): CreateTempSalesProductDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTempSalesProductDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productId"] = this.productId;
        data["barCode"] = this.barCode;
        data["code"] = this.code;
        data["name"] = this.name;
        data["stockBalanceId"] = this.stockBalanceId;
        data["expiryDate"] = this.expiryDate ? this.expiryDate.toISOString() : <any>undefined;
        data["batchNumber"] = this.batchNumber;
        data["warehouseId"] = this.warehouseId;
        data["warehouseCode"] = this.warehouseCode;
        data["warehouseName"] = this.warehouseName;
        data["bookBalanceQuantity"] = this.bookBalanceQuantity;
        data["bookBalanceUnitOfMeasureUnit"] = this.bookBalanceUnitOfMeasureUnit;
        data["costPrice"] = this.costPrice;
        data["sellingPrice"] = this.sellingPrice;
        data["maximumRetailPrice"] = this.maximumRetailPrice;
        data["isSelected"] = this.isSelected;
        data["discountRate"] = this.discountRate;
        data["discountAmount"] = this.discountAmount;
        data["quantity"] = this.quantity;
        data["lineTotal"] = this.lineTotal;
        data["isActive"] = this.isActive;
        return data; 
    }

    clone(): CreateTempSalesProductDto {
        const json = this.toJSON();
        let result = new CreateTempSalesProductDto();
        result.init(json);
        return result;
    }
}

export interface ICreateTempSalesProductDto {
    productId: string;
    barCode: string | undefined;
    code: string;
    name: string;
    stockBalanceId: string;
    expiryDate: moment.Moment | undefined;
    batchNumber: string | undefined;
    warehouseId: string | undefined;
    warehouseCode: string | undefined;
    warehouseName: string | undefined;
    bookBalanceQuantity: number;
    bookBalanceUnitOfMeasureUnit: string | undefined;
    costPrice: number;
    sellingPrice: number;
    maximumRetailPrice: number;
    isSelected: boolean;
    discountRate: number;
    discountAmount: number;
    quantity: number;
    lineTotal: number;
    isActive: boolean;
}

export class CreateNonInventoryProductDto implements ICreateNonInventoryProductDto {
    id: string | undefined;
    sequenceNumber: number;
    tempSaleId: number | undefined;
    productId: string;
    productCode: string;
    productName: string;
    warehouseId: string | undefined;
    warehouseCode: string | undefined;
    warehouseName: string | undefined;
    quantity: number;
    quantityUnitOfMeasureUnit: string | undefined;
    discountRate: number;
    discountAmount: number;
    lineTotal: number;
    costPrice: number;
    sellingPrice: number;
    maximumRetailPrice: number;

    constructor(data?: ICreateNonInventoryProductDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.sequenceNumber = _data["sequenceNumber"];
            this.tempSaleId = _data["tempSaleId"];
            this.productId = _data["productId"];
            this.productCode = _data["productCode"];
            this.productName = _data["productName"];
            this.warehouseId = _data["warehouseId"];
            this.warehouseCode = _data["warehouseCode"];
            this.warehouseName = _data["warehouseName"];
            this.quantity = _data["quantity"];
            this.quantityUnitOfMeasureUnit = _data["quantityUnitOfMeasureUnit"];
            this.discountRate = _data["discountRate"];
            this.discountAmount = _data["discountAmount"];
            this.lineTotal = _data["lineTotal"];
            this.costPrice = _data["costPrice"];
            this.sellingPrice = _data["sellingPrice"];
            this.maximumRetailPrice = _data["maximumRetailPrice"];
        }
    }

    static fromJS(data: any): CreateNonInventoryProductDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateNonInventoryProductDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["sequenceNumber"] = this.sequenceNumber;
        data["tempSaleId"] = this.tempSaleId;
        data["productId"] = this.productId;
        data["productCode"] = this.productCode;
        data["productName"] = this.productName;
        data["warehouseId"] = this.warehouseId;
        data["warehouseCode"] = this.warehouseCode;
        data["warehouseName"] = this.warehouseName;
        data["quantity"] = this.quantity;
        data["quantityUnitOfMeasureUnit"] = this.quantityUnitOfMeasureUnit;
        data["discountRate"] = this.discountRate;
        data["discountAmount"] = this.discountAmount;
        data["lineTotal"] = this.lineTotal;
        data["costPrice"] = this.costPrice;
        data["sellingPrice"] = this.sellingPrice;
        data["maximumRetailPrice"] = this.maximumRetailPrice;
        return data; 
    }

    clone(): CreateNonInventoryProductDto {
        const json = this.toJSON();
        let result = new CreateNonInventoryProductDto();
        result.init(json);
        return result;
    }
}

export interface ICreateNonInventoryProductDto {
    id: string | undefined;
    sequenceNumber: number;
    tempSaleId: number | undefined;
    productId: string;
    productCode: string;
    productName: string;
    warehouseId: string | undefined;
    warehouseCode: string | undefined;
    warehouseName: string | undefined;
    quantity: number;
    quantityUnitOfMeasureUnit: string | undefined;
    discountRate: number;
    discountAmount: number;
    lineTotal: number;
    costPrice: number;
    sellingPrice: number;
    maximumRetailPrice: number;
}

export class CreateOrUpdateTempSaleDto implements ICreateOrUpdateTempSaleDto {
    id: number | undefined;
    customerId: string | undefined;
    customerCode: string | undefined;
    customerName: string | undefined;
    discountRate: number;
    discountAmount: number;
    taxRate: number;
    taxAmount: number;
    grossAmount: number;
    netAmount: number;
    remarks: string | undefined;
    isActive: boolean;
    tempSalesProducts: CreateTempSalesProductDto[] | undefined;
    nonInventoryProducts: CreateNonInventoryProductDto[] | undefined;

    constructor(data?: ICreateOrUpdateTempSaleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.customerId = _data["customerId"];
            this.customerCode = _data["customerCode"];
            this.customerName = _data["customerName"];
            this.discountRate = _data["discountRate"];
            this.discountAmount = _data["discountAmount"];
            this.taxRate = _data["taxRate"];
            this.taxAmount = _data["taxAmount"];
            this.grossAmount = _data["grossAmount"];
            this.netAmount = _data["netAmount"];
            this.remarks = _data["remarks"];
            this.isActive = _data["isActive"];
            if (Array.isArray(_data["tempSalesProducts"])) {
                this.tempSalesProducts = [] as any;
                for (let item of _data["tempSalesProducts"])
                    this.tempSalesProducts.push(CreateTempSalesProductDto.fromJS(item));
            }
            if (Array.isArray(_data["nonInventoryProducts"])) {
                this.nonInventoryProducts = [] as any;
                for (let item of _data["nonInventoryProducts"])
                    this.nonInventoryProducts.push(CreateNonInventoryProductDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateOrUpdateTempSaleDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateTempSaleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["customerId"] = this.customerId;
        data["customerCode"] = this.customerCode;
        data["customerName"] = this.customerName;
        data["discountRate"] = this.discountRate;
        data["discountAmount"] = this.discountAmount;
        data["taxRate"] = this.taxRate;
        data["taxAmount"] = this.taxAmount;
        data["grossAmount"] = this.grossAmount;
        data["netAmount"] = this.netAmount;
        data["remarks"] = this.remarks;
        data["isActive"] = this.isActive;
        if (Array.isArray(this.tempSalesProducts)) {
            data["tempSalesProducts"] = [];
            for (let item of this.tempSalesProducts)
                data["tempSalesProducts"].push(item.toJSON());
        }
        if (Array.isArray(this.nonInventoryProducts)) {
            data["nonInventoryProducts"] = [];
            for (let item of this.nonInventoryProducts)
                data["nonInventoryProducts"].push(item.toJSON());
        }
        return data; 
    }

    clone(): CreateOrUpdateTempSaleDto {
        const json = this.toJSON();
        let result = new CreateOrUpdateTempSaleDto();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateTempSaleDto {
    id: number | undefined;
    customerId: string | undefined;
    customerCode: string | undefined;
    customerName: string | undefined;
    discountRate: number;
    discountAmount: number;
    taxRate: number;
    taxAmount: number;
    grossAmount: number;
    netAmount: number;
    remarks: string | undefined;
    isActive: boolean;
    tempSalesProducts: CreateTempSalesProductDto[] | undefined;
    nonInventoryProducts: CreateNonInventoryProductDto[] | undefined;
}

export class TempSalesProductDto implements ITempSalesProductDto {
    tempSaleId: number;
    productId: string;
    barCode: string | undefined;
    code: string;
    name: string;
    stockBalanceId: string;
    expiryDate: moment.Moment | undefined;
    batchNumber: string | undefined;
    warehouseId: string | undefined;
    warehouseCode: string | undefined;
    warehouseName: string | undefined;
    bookBalanceQuantity: number;
    bookBalanceUnitOfMeasureUnit: string | undefined;
    costPrice: number;
    sellingPrice: number;
    maximumRetailPrice: number;
    isSelected: boolean;
    discountRate: number;
    discountAmount: number;
    quantity: number;
    lineTotal: number;
    isActive: boolean;
    id: number;

    constructor(data?: ITempSalesProductDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tempSaleId = _data["tempSaleId"];
            this.productId = _data["productId"];
            this.barCode = _data["barCode"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.stockBalanceId = _data["stockBalanceId"];
            this.expiryDate = _data["expiryDate"] ? moment(_data["expiryDate"].toString()) : <any>undefined;
            this.batchNumber = _data["batchNumber"];
            this.warehouseId = _data["warehouseId"];
            this.warehouseCode = _data["warehouseCode"];
            this.warehouseName = _data["warehouseName"];
            this.bookBalanceQuantity = _data["bookBalanceQuantity"];
            this.bookBalanceUnitOfMeasureUnit = _data["bookBalanceUnitOfMeasureUnit"];
            this.costPrice = _data["costPrice"];
            this.sellingPrice = _data["sellingPrice"];
            this.maximumRetailPrice = _data["maximumRetailPrice"];
            this.isSelected = _data["isSelected"];
            this.discountRate = _data["discountRate"];
            this.discountAmount = _data["discountAmount"];
            this.quantity = _data["quantity"];
            this.lineTotal = _data["lineTotal"];
            this.isActive = _data["isActive"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TempSalesProductDto {
        data = typeof data === 'object' ? data : {};
        let result = new TempSalesProductDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tempSaleId"] = this.tempSaleId;
        data["productId"] = this.productId;
        data["barCode"] = this.barCode;
        data["code"] = this.code;
        data["name"] = this.name;
        data["stockBalanceId"] = this.stockBalanceId;
        data["expiryDate"] = this.expiryDate ? this.expiryDate.toISOString() : <any>undefined;
        data["batchNumber"] = this.batchNumber;
        data["warehouseId"] = this.warehouseId;
        data["warehouseCode"] = this.warehouseCode;
        data["warehouseName"] = this.warehouseName;
        data["bookBalanceQuantity"] = this.bookBalanceQuantity;
        data["bookBalanceUnitOfMeasureUnit"] = this.bookBalanceUnitOfMeasureUnit;
        data["costPrice"] = this.costPrice;
        data["sellingPrice"] = this.sellingPrice;
        data["maximumRetailPrice"] = this.maximumRetailPrice;
        data["isSelected"] = this.isSelected;
        data["discountRate"] = this.discountRate;
        data["discountAmount"] = this.discountAmount;
        data["quantity"] = this.quantity;
        data["lineTotal"] = this.lineTotal;
        data["isActive"] = this.isActive;
        data["id"] = this.id;
        return data; 
    }

    clone(): TempSalesProductDto {
        const json = this.toJSON();
        let result = new TempSalesProductDto();
        result.init(json);
        return result;
    }
}

export interface ITempSalesProductDto {
    tempSaleId: number;
    productId: string;
    barCode: string | undefined;
    code: string;
    name: string;
    stockBalanceId: string;
    expiryDate: moment.Moment | undefined;
    batchNumber: string | undefined;
    warehouseId: string | undefined;
    warehouseCode: string | undefined;
    warehouseName: string | undefined;
    bookBalanceQuantity: number;
    bookBalanceUnitOfMeasureUnit: string | undefined;
    costPrice: number;
    sellingPrice: number;
    maximumRetailPrice: number;
    isSelected: boolean;
    discountRate: number;
    discountAmount: number;
    quantity: number;
    lineTotal: number;
    isActive: boolean;
    id: number;
}

export class TempSaleDto implements ITempSaleDto {
    customerId: string | undefined;
    customerCode: string | undefined;
    customerName: string | undefined;
    discountRate: number;
    discountAmount: number;
    taxRate: number;
    taxAmount: number;
    grossAmount: number;
    netAmount: number;
    remarks: string | undefined;
    isActive: boolean;
    tempSalesProducts: TempSalesProductDto[] | undefined;
    id: number;

    constructor(data?: ITempSaleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.customerId = _data["customerId"];
            this.customerCode = _data["customerCode"];
            this.customerName = _data["customerName"];
            this.discountRate = _data["discountRate"];
            this.discountAmount = _data["discountAmount"];
            this.taxRate = _data["taxRate"];
            this.taxAmount = _data["taxAmount"];
            this.grossAmount = _data["grossAmount"];
            this.netAmount = _data["netAmount"];
            this.remarks = _data["remarks"];
            this.isActive = _data["isActive"];
            if (Array.isArray(_data["tempSalesProducts"])) {
                this.tempSalesProducts = [] as any;
                for (let item of _data["tempSalesProducts"])
                    this.tempSalesProducts.push(TempSalesProductDto.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TempSaleDto {
        data = typeof data === 'object' ? data : {};
        let result = new TempSaleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customerId"] = this.customerId;
        data["customerCode"] = this.customerCode;
        data["customerName"] = this.customerName;
        data["discountRate"] = this.discountRate;
        data["discountAmount"] = this.discountAmount;
        data["taxRate"] = this.taxRate;
        data["taxAmount"] = this.taxAmount;
        data["grossAmount"] = this.grossAmount;
        data["netAmount"] = this.netAmount;
        data["remarks"] = this.remarks;
        data["isActive"] = this.isActive;
        if (Array.isArray(this.tempSalesProducts)) {
            data["tempSalesProducts"] = [];
            for (let item of this.tempSalesProducts)
                data["tempSalesProducts"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data; 
    }

    clone(): TempSaleDto {
        const json = this.toJSON();
        let result = new TempSaleDto();
        result.init(json);
        return result;
    }
}

export interface ITempSaleDto {
    customerId: string | undefined;
    customerCode: string | undefined;
    customerName: string | undefined;
    discountRate: number;
    discountAmount: number;
    taxRate: number;
    taxAmount: number;
    grossAmount: number;
    netAmount: number;
    remarks: string | undefined;
    isActive: boolean;
    tempSalesProducts: TempSalesProductDto[] | undefined;
    id: number;
}

export class NonInventoryProductDto implements INonInventoryProductDto {
    sequenceNumber: number;
    tempSaleId: number;
    productId: string;
    productCode: string;
    productName: string;
    warehouseId: string | undefined;
    warehouseCode: string | undefined;
    warehouseName: string | undefined;
    quantity: number;
    quantityUnitOfMeasureUnit: string | undefined;
    discountRate: number;
    discountAmount: number;
    lineTotal: number;
    costPrice: number;
    sellingPrice: number;
    maximumRetailPrice: number;
    id: string;

    constructor(data?: INonInventoryProductDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sequenceNumber = _data["sequenceNumber"];
            this.tempSaleId = _data["tempSaleId"];
            this.productId = _data["productId"];
            this.productCode = _data["productCode"];
            this.productName = _data["productName"];
            this.warehouseId = _data["warehouseId"];
            this.warehouseCode = _data["warehouseCode"];
            this.warehouseName = _data["warehouseName"];
            this.quantity = _data["quantity"];
            this.quantityUnitOfMeasureUnit = _data["quantityUnitOfMeasureUnit"];
            this.discountRate = _data["discountRate"];
            this.discountAmount = _data["discountAmount"];
            this.lineTotal = _data["lineTotal"];
            this.costPrice = _data["costPrice"];
            this.sellingPrice = _data["sellingPrice"];
            this.maximumRetailPrice = _data["maximumRetailPrice"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): NonInventoryProductDto {
        data = typeof data === 'object' ? data : {};
        let result = new NonInventoryProductDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sequenceNumber"] = this.sequenceNumber;
        data["tempSaleId"] = this.tempSaleId;
        data["productId"] = this.productId;
        data["productCode"] = this.productCode;
        data["productName"] = this.productName;
        data["warehouseId"] = this.warehouseId;
        data["warehouseCode"] = this.warehouseCode;
        data["warehouseName"] = this.warehouseName;
        data["quantity"] = this.quantity;
        data["quantityUnitOfMeasureUnit"] = this.quantityUnitOfMeasureUnit;
        data["discountRate"] = this.discountRate;
        data["discountAmount"] = this.discountAmount;
        data["lineTotal"] = this.lineTotal;
        data["costPrice"] = this.costPrice;
        data["sellingPrice"] = this.sellingPrice;
        data["maximumRetailPrice"] = this.maximumRetailPrice;
        data["id"] = this.id;
        return data; 
    }

    clone(): NonInventoryProductDto {
        const json = this.toJSON();
        let result = new NonInventoryProductDto();
        result.init(json);
        return result;
    }
}

export interface INonInventoryProductDto {
    sequenceNumber: number;
    tempSaleId: number;
    productId: string;
    productCode: string;
    productName: string;
    warehouseId: string | undefined;
    warehouseCode: string | undefined;
    warehouseName: string | undefined;
    quantity: number;
    quantityUnitOfMeasureUnit: string | undefined;
    discountRate: number;
    discountAmount: number;
    lineTotal: number;
    costPrice: number;
    sellingPrice: number;
    maximumRetailPrice: number;
    id: string;
}

export class ApplicationInfoDto implements IApplicationInfoDto {
    version: string | undefined;
    releaseDate: moment.Moment;
    features: { [key: string]: boolean; } | undefined;

    constructor(data?: IApplicationInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.version = _data["version"];
            this.releaseDate = _data["releaseDate"] ? moment(_data["releaseDate"].toString()) : <any>undefined;
            if (_data["features"]) {
                this.features = {} as any;
                for (let key in _data["features"]) {
                    if (_data["features"].hasOwnProperty(key))
                        (<any>this.features)[key] = _data["features"][key];
                }
            }
        }
    }

    static fromJS(data: any): ApplicationInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["version"] = this.version;
        data["releaseDate"] = this.releaseDate ? this.releaseDate.toISOString() : <any>undefined;
        if (this.features) {
            data["features"] = {};
            for (let key in this.features) {
                if (this.features.hasOwnProperty(key))
                    (<any>data["features"])[key] = this.features[key];
            }
        }
        return data; 
    }

    clone(): ApplicationInfoDto {
        const json = this.toJSON();
        let result = new ApplicationInfoDto();
        result.init(json);
        return result;
    }
}

export interface IApplicationInfoDto {
    version: string | undefined;
    releaseDate: moment.Moment;
    features: { [key: string]: boolean; } | undefined;
}

export class UserLoginInfoDto implements IUserLoginInfoDto {
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    id: number;

    constructor(data?: IUserLoginInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.userName = _data["userName"];
            this.emailAddress = _data["emailAddress"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UserLoginInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserLoginInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["id"] = this.id;
        return data; 
    }

    clone(): UserLoginInfoDto {
        const json = this.toJSON();
        let result = new UserLoginInfoDto();
        result.init(json);
        return result;
    }
}

export interface IUserLoginInfoDto {
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    id: number;
}

export class TenantLoginInfoDto implements ITenantLoginInfoDto {
    tenancyName: string | undefined;
    name: string | undefined;
    id: number;

    constructor(data?: ITenantLoginInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenancyName = _data["tenancyName"];
            this.name = _data["name"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TenantLoginInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantLoginInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["id"] = this.id;
        return data; 
    }

    clone(): TenantLoginInfoDto {
        const json = this.toJSON();
        let result = new TenantLoginInfoDto();
        result.init(json);
        return result;
    }
}

export interface ITenantLoginInfoDto {
    tenancyName: string | undefined;
    name: string | undefined;
    id: number;
}

export class GetCurrentLoginInformationsOutput implements IGetCurrentLoginInformationsOutput {
    application: ApplicationInfoDto;
    user: UserLoginInfoDto;
    tenant: TenantLoginInfoDto;

    constructor(data?: IGetCurrentLoginInformationsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.application = _data["application"] ? ApplicationInfoDto.fromJS(_data["application"]) : <any>undefined;
            this.user = _data["user"] ? UserLoginInfoDto.fromJS(_data["user"]) : <any>undefined;
            this.tenant = _data["tenant"] ? TenantLoginInfoDto.fromJS(_data["tenant"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetCurrentLoginInformationsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetCurrentLoginInformationsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["application"] = this.application ? this.application.toJSON() : <any>undefined;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["tenant"] = this.tenant ? this.tenant.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetCurrentLoginInformationsOutput {
        const json = this.toJSON();
        let result = new GetCurrentLoginInformationsOutput();
        result.init(json);
        return result;
    }
}

export interface IGetCurrentLoginInformationsOutput {
    application: ApplicationInfoDto;
    user: UserLoginInfoDto;
    tenant: TenantLoginInfoDto;
}

export class CreateTenantDto implements ICreateTenantDto {
    tenancyName: string;
    name: string;
    adminEmailAddress: string;
    connectionString: string | undefined;
    isActive: boolean;

    constructor(data?: ICreateTenantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenancyName = _data["tenancyName"];
            this.name = _data["name"];
            this.adminEmailAddress = _data["adminEmailAddress"];
            this.connectionString = _data["connectionString"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): CreateTenantDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTenantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["adminEmailAddress"] = this.adminEmailAddress;
        data["connectionString"] = this.connectionString;
        data["isActive"] = this.isActive;
        return data; 
    }

    clone(): CreateTenantDto {
        const json = this.toJSON();
        let result = new CreateTenantDto();
        result.init(json);
        return result;
    }
}

export interface ICreateTenantDto {
    tenancyName: string;
    name: string;
    adminEmailAddress: string;
    connectionString: string | undefined;
    isActive: boolean;
}

export class TenantDto implements ITenantDto {
    tenancyName: string;
    name: string;
    isActive: boolean;
    id: number;

    constructor(data?: ITenantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenancyName = _data["tenancyName"];
            this.name = _data["name"];
            this.isActive = _data["isActive"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TenantDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["isActive"] = this.isActive;
        data["id"] = this.id;
        return data; 
    }

    clone(): TenantDto {
        const json = this.toJSON();
        let result = new TenantDto();
        result.init(json);
        return result;
    }
}

export interface ITenantDto {
    tenancyName: string;
    name: string;
    isActive: boolean;
    id: number;
}

export class TenantDtoPagedResultDto implements ITenantDtoPagedResultDto {
    totalCount: number;
    items: TenantDto[] | undefined;

    constructor(data?: ITenantDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(TenantDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TenantDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): TenantDtoPagedResultDto {
        const json = this.toJSON();
        let result = new TenantDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface ITenantDtoPagedResultDto {
    totalCount: number;
    items: TenantDto[] | undefined;
}

export class AuthenticateModel implements IAuthenticateModel {
    userNameOrEmailAddress: string;
    password: string;
    rememberClient: boolean;

    constructor(data?: IAuthenticateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userNameOrEmailAddress = _data["userNameOrEmailAddress"];
            this.password = _data["password"];
            this.rememberClient = _data["rememberClient"];
        }
    }

    static fromJS(data: any): AuthenticateModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userNameOrEmailAddress"] = this.userNameOrEmailAddress;
        data["password"] = this.password;
        data["rememberClient"] = this.rememberClient;
        return data; 
    }

    clone(): AuthenticateModel {
        const json = this.toJSON();
        let result = new AuthenticateModel();
        result.init(json);
        return result;
    }
}

export interface IAuthenticateModel {
    userNameOrEmailAddress: string;
    password: string;
    rememberClient: boolean;
}

export class AuthenticateResultModel implements IAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
    userId: number;

    constructor(data?: IAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessToken = _data["accessToken"];
            this.encryptedAccessToken = _data["encryptedAccessToken"];
            this.expireInSeconds = _data["expireInSeconds"];
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): AuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        data["userId"] = this.userId;
        return data; 
    }

    clone(): AuthenticateResultModel {
        const json = this.toJSON();
        let result = new AuthenticateResultModel();
        result.init(json);
        return result;
    }
}

export interface IAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
    userId: number;
}

export class ExternalLoginProviderInfoModel implements IExternalLoginProviderInfoModel {
    name: string | undefined;
    clientId: string | undefined;

    constructor(data?: IExternalLoginProviderInfoModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.clientId = _data["clientId"];
        }
    }

    static fromJS(data: any): ExternalLoginProviderInfoModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalLoginProviderInfoModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["clientId"] = this.clientId;
        return data; 
    }

    clone(): ExternalLoginProviderInfoModel {
        const json = this.toJSON();
        let result = new ExternalLoginProviderInfoModel();
        result.init(json);
        return result;
    }
}

export interface IExternalLoginProviderInfoModel {
    name: string | undefined;
    clientId: string | undefined;
}

export class ExternalAuthenticateModel implements IExternalAuthenticateModel {
    authProvider: string;
    providerKey: string;
    providerAccessCode: string;

    constructor(data?: IExternalAuthenticateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.authProvider = _data["authProvider"];
            this.providerKey = _data["providerKey"];
            this.providerAccessCode = _data["providerAccessCode"];
        }
    }

    static fromJS(data: any): ExternalAuthenticateModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalAuthenticateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["authProvider"] = this.authProvider;
        data["providerKey"] = this.providerKey;
        data["providerAccessCode"] = this.providerAccessCode;
        return data; 
    }

    clone(): ExternalAuthenticateModel {
        const json = this.toJSON();
        let result = new ExternalAuthenticateModel();
        result.init(json);
        return result;
    }
}

export interface IExternalAuthenticateModel {
    authProvider: string;
    providerKey: string;
    providerAccessCode: string;
}

export class ExternalAuthenticateResultModel implements IExternalAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
    waitingForActivation: boolean;

    constructor(data?: IExternalAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessToken = _data["accessToken"];
            this.encryptedAccessToken = _data["encryptedAccessToken"];
            this.expireInSeconds = _data["expireInSeconds"];
            this.waitingForActivation = _data["waitingForActivation"];
        }
    }

    static fromJS(data: any): ExternalAuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalAuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        data["waitingForActivation"] = this.waitingForActivation;
        return data; 
    }

    clone(): ExternalAuthenticateResultModel {
        const json = this.toJSON();
        let result = new ExternalAuthenticateResultModel();
        result.init(json);
        return result;
    }
}

export interface IExternalAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
    waitingForActivation: boolean;
}

export class CreateUserDto implements ICreateUserDto {
    userName: string;
    name: string;
    surname: string;
    emailAddress: string;
    isActive: boolean;
    roleNames: string[] | undefined;
    password: string;

    constructor(data?: ICreateUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.emailAddress = _data["emailAddress"];
            this.isActive = _data["isActive"];
            if (Array.isArray(_data["roleNames"])) {
                this.roleNames = [] as any;
                for (let item of _data["roleNames"])
                    this.roleNames.push(item);
            }
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): CreateUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["emailAddress"] = this.emailAddress;
        data["isActive"] = this.isActive;
        if (Array.isArray(this.roleNames)) {
            data["roleNames"] = [];
            for (let item of this.roleNames)
                data["roleNames"].push(item);
        }
        data["password"] = this.password;
        return data; 
    }

    clone(): CreateUserDto {
        const json = this.toJSON();
        let result = new CreateUserDto();
        result.init(json);
        return result;
    }
}

export interface ICreateUserDto {
    userName: string;
    name: string;
    surname: string;
    emailAddress: string;
    isActive: boolean;
    roleNames: string[] | undefined;
    password: string;
}

export class UserDto implements IUserDto {
    userName: string;
    name: string;
    surname: string;
    emailAddress: string;
    isActive: boolean;
    fullName: string | undefined;
    lastLoginTime: moment.Moment | undefined;
    creationTime: moment.Moment;
    roleNames: string[] | undefined;
    id: number;

    constructor(data?: IUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.emailAddress = _data["emailAddress"];
            this.isActive = _data["isActive"];
            this.fullName = _data["fullName"];
            this.lastLoginTime = _data["lastLoginTime"] ? moment(_data["lastLoginTime"].toString()) : <any>undefined;
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            if (Array.isArray(_data["roleNames"])) {
                this.roleNames = [] as any;
                for (let item of _data["roleNames"])
                    this.roleNames.push(item);
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UserDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["emailAddress"] = this.emailAddress;
        data["isActive"] = this.isActive;
        data["fullName"] = this.fullName;
        data["lastLoginTime"] = this.lastLoginTime ? this.lastLoginTime.toISOString() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        if (Array.isArray(this.roleNames)) {
            data["roleNames"] = [];
            for (let item of this.roleNames)
                data["roleNames"].push(item);
        }
        data["id"] = this.id;
        return data; 
    }

    clone(): UserDto {
        const json = this.toJSON();
        let result = new UserDto();
        result.init(json);
        return result;
    }
}

export interface IUserDto {
    userName: string;
    name: string;
    surname: string;
    emailAddress: string;
    isActive: boolean;
    fullName: string | undefined;
    lastLoginTime: moment.Moment | undefined;
    creationTime: moment.Moment;
    roleNames: string[] | undefined;
    id: number;
}

export class Int64EntityDto implements IInt64EntityDto {
    id: number;

    constructor(data?: IInt64EntityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Int64EntityDto {
        data = typeof data === 'object' ? data : {};
        let result = new Int64EntityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }

    clone(): Int64EntityDto {
        const json = this.toJSON();
        let result = new Int64EntityDto();
        result.init(json);
        return result;
    }
}

export interface IInt64EntityDto {
    id: number;
}

export class RoleDtoListResultDto implements IRoleDtoListResultDto {
    items: RoleDto[] | undefined;

    constructor(data?: IRoleDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(RoleDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RoleDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): RoleDtoListResultDto {
        const json = this.toJSON();
        let result = new RoleDtoListResultDto();
        result.init(json);
        return result;
    }
}

export interface IRoleDtoListResultDto {
    items: RoleDto[] | undefined;
}

export class ChangeUserLanguageDto implements IChangeUserLanguageDto {
    languageName: string;

    constructor(data?: IChangeUserLanguageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.languageName = _data["languageName"];
        }
    }

    static fromJS(data: any): ChangeUserLanguageDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeUserLanguageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["languageName"] = this.languageName;
        return data; 
    }

    clone(): ChangeUserLanguageDto {
        const json = this.toJSON();
        let result = new ChangeUserLanguageDto();
        result.init(json);
        return result;
    }
}

export interface IChangeUserLanguageDto {
    languageName: string;
}

export class ChangePasswordDto implements IChangePasswordDto {
    currentPassword: string;
    newPassword: string;

    constructor(data?: IChangePasswordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.currentPassword = _data["currentPassword"];
            this.newPassword = _data["newPassword"];
        }
    }

    static fromJS(data: any): ChangePasswordDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChangePasswordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentPassword"] = this.currentPassword;
        data["newPassword"] = this.newPassword;
        return data; 
    }

    clone(): ChangePasswordDto {
        const json = this.toJSON();
        let result = new ChangePasswordDto();
        result.init(json);
        return result;
    }
}

export interface IChangePasswordDto {
    currentPassword: string;
    newPassword: string;
}

export class ResetPasswordDto implements IResetPasswordDto {
    adminPassword: string;
    userId: number;
    newPassword: string;

    constructor(data?: IResetPasswordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.adminPassword = _data["adminPassword"];
            this.userId = _data["userId"];
            this.newPassword = _data["newPassword"];
        }
    }

    static fromJS(data: any): ResetPasswordDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["adminPassword"] = this.adminPassword;
        data["userId"] = this.userId;
        data["newPassword"] = this.newPassword;
        return data; 
    }

    clone(): ResetPasswordDto {
        const json = this.toJSON();
        let result = new ResetPasswordDto();
        result.init(json);
        return result;
    }
}

export interface IResetPasswordDto {
    adminPassword: string;
    userId: number;
    newPassword: string;
}

export class UserDtoPagedResultDto implements IUserDtoPagedResultDto {
    totalCount: number;
    items: UserDto[] | undefined;

    constructor(data?: IUserDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(UserDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UserDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): UserDtoPagedResultDto {
        const json = this.toJSON();
        let result = new UserDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IUserDtoPagedResultDto {
    totalCount: number;
    items: UserDto[] | undefined;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}